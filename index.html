<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Palm Photo Capture with Custom Camera</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- TensorFlow.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <!-- MediaPipe Hands CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js"></script>
    <!-- HandPose model from TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose@0.0.7/dist/handpose.min.js"></script>

    <style>
        /* Custom styles for better visual appeal */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px; /* Add some padding for smaller screens */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }

        /* User's original palm upload container styles */
        .palm-upload-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }
        /* New container for each palm box and its buttons */
        .palm-input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px; /* Space between box and buttons */
        }

        .upload-box {
            border: 2px dashed #d7bfb9;
            border-radius: 8px;
            width: 180px;
            height: 180px; /* Increased height to accommodate image */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            background-color: #fffaf8;
            font-family: sans-serif;
            font-size: 14px;
            color: #7a3e2f;
            text-align: center;
            position: relative; /* For positioning captured image */
            overflow: hidden; /* Hide overflow for rounded corners */
            padding: 10px; /* Add padding inside the box */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }
        .upload-box .placeholder-text {
            display: flex; /* Ensure flex for centering */
            align-items: center;
            justify-content: center;
            height: 100%; /* Occupy full height when no images */
            width: 100%;
            padding: 0 5px;
            box-sizing: border-box;
        }
        .upload-box .photo-gallery {
            display: flex;
            flex-wrap: wrap;
            gap: 5px; /* Small gap between images */
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%; /* Fill the upload-box */
            overflow-y: auto; /* Allow scrolling if many photos */
            padding: 5px; /* Padding inside gallery */
            box-sizing: border-box;
        }
        .photo-card {
            position: relative;
            width: 70px; /* Thumbnail size */
            height: 70px;
            border: 1px solid #ccc;
            border-radius: 4px;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0; /* Prevent cards from shrinking */
        }
        .photo-card img {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Cover the thumbnail area */
            border-radius: 4px;
        }
        .photo-card .delete-photo-btn {
            position: absolute;
            top: 2px;
            right: 2px;
            background-color: rgba(239, 68, 68, 0.8); /* Red with transparency */
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            line-height: 1;
            padding: 0;
            opacity: 0.8;
            transition: opacity 0.2s;
            z-index: 10; /* Ensure button is above image */
        }
        .photo-card .delete-photo-btn:hover {
            opacity: 1;
        }

        /* Styles for the buttons now they are outside the box */
        button.capture-trigger-btn,
        button.remove-image-btn {
            background-color: #4f46e5;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.06);
            border: none;
            display: flex; /* For icon centering */
            align-items: center;
            justify-content: center;
            gap: 0.5rem; /* Space between icon and text if text is present */
        }
        button.capture-trigger-btn:hover,
        button.remove-image-btn:hover {
            background-color: #4338ca;
            transform: translateY(-1px);
        }
        button.remove-image-btn {
            background-color: #ef4444; /* Red color for remove button */
        }
        button.remove-image-btn:hover {
            background-color: #dc2626;
        }

        /* Modal specific styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .modal.show {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.08);
            max-width: 95vw; /* Responsive width for modal */
            width: 500px; /* Max width for desktop */
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .modal-header {
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e5e7eb;
        }
        .modal-header h2 {
            font-size: 1.25rem;
            font-weight: 700;
            color: #374151;
        }
        .modal-close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6b7280;
            transition: color 0.2s;
        }
        .modal-close-btn:hover {
            color: #1f2937;
        }

        /* Camera app specific styles (from previous version, adapted for modal) */
        .camera-area {
            position: relative;
            width: 100%;
            /* Default to landscape 4:3 aspect ratio for desktop */
            padding-top: 75%; /* (height / width) * 100% = (3/4) * 100% */
            overflow: hidden;
            background-color: #000;
        }

        /* Adjust for mobile portrait (e.g., up to 768px width) */
        @media (max-width: 768px) {
            .camera-area {
                /* For portrait, use a 3:4 aspect ratio (height > width) */
                padding-top: 133.33%; /* (4/3) * 100% */
            }
        }

        video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            /* transform: scaleX(-1); This will be set dynamically by JS */
        }
        #hiddenCanvas, #motionDetectionCanvas {
            display: none;
        }
        .hand-outline-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%; /* Changed from 60% to 90% */
            height: 90%; /* Changed from 60% to 90% */
            border: 4px solid;
            border-radius: 1rem;
            pointer-events: none;
            transition: border-color 0.3s ease-in-out;
            overflow: hidden; /* Crucial to contain the scanning line */
        }
        .red-outline {
            border-color: #ef4444;
        }
        .green-outline {
            border-color: #22c55e;
        }
        /* Scanning line effect */
        .hand-outline-overlay::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%; /* Start off-screen to the left */
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(34, 197, 94, 0.3), transparent); /* Green gradient */
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        .hand-outline-overlay.scanning::after {
            opacity: 1;
            animation: scan-line 2s infinite linear; /* Animate the scan line */
        }

        @keyframes scan-line {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        /* Message box overlay on camera view */
        #cameraMessageBox {
            position: absolute;
            bottom: 10px; /* Adjust as needed */
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 300px; /* Limit width on larger screens */
            padding: 8px 15px;
            border-radius: 0.75rem;
            background-color: rgba(255, 255, 255, 0.85); /* Semi-transparent white */
            color: #374151;
            font-size: 0.9rem;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 50; /* Above video, below outline */
            display: none; /* Hidden by default */
            box-sizing: border-box;
        }
        /* Color variations for camera message box */
        #cameraMessageBox.message-info { background-color: rgba(224, 231, 255, 0.85); color: #4f46e5; }
        #cameraMessageBox.message-warning { background-color: rgba(255, 248, 224, 0.85); color: #f59e0b; }
        #cameraMessageBox.message-error { background-color: rgba(254, 242, 242, 0.85); color: #ef4444; }
        #cameraMessageBox.message-success { background-color: rgba(236, 253, 245, 0.85); color: #10b981; }


        .controls {
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .button-group {
            display: flex;
            justify-content: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        /* New class to control visibility of zoom options */
        .zoom-controls-group {
            display: flex; /* Default to flex */
            justify-content: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        /* Hide zoom controls if not supported */
        .zoom-controls-group.hidden-zoom {
            display: none;
        }

        button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: none;
            display: flex; /* For icon centering */
            align-items: center;
            justify-content: center;
            /* No gap here, as text is removed */
        }
        button i {
            font-size: 1.2em; /* Adjust icon size */
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.06), 0 1px 2px -1px rgba(0, 0, 0, 0.04);
        }
        .btn-primary {
            background-color: #4f46e5;
            color: white;
        }
        .btn-primary:hover {
            background-color: #4338ca;
        }
        .btn-secondary {
            background-color: #e5e7eb;
            color: #374151;
        }
        .btn-secondary:hover {
            background-color: #d1d5db;
        }
        .btn-capture {
            background-color: #10b981;
            color: white;
        }
        .btn-capture:hover {
            background-color: #059669;
        }
        .btn-toggle-auto-capture {
            background-color: #6366f1; /* Indigo for toggle */
            color: white;
        }
        .btn-toggle-auto-capture.active {
            background-color: #10b981; /* Green when active */
        }
        .btn-toggle-auto-capture:hover {
            background-color: #4f46e5;
        }
        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 8px;
            background: #e0e7ff;
            border-radius: 5px;
            outline: none;
            transition: opacity .2s;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4f46e5;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4f46e5;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        /* Style for the zoom slider label */
        .zoom-slider-label {
            display: block; /* Ensure it takes its own line */
            text-align: center;
            color: #374151;
            font-weight: 500;
        }
        /* Hide the zoom slider label if zoom is not supported */
        .zoom-slider-label.hidden-zoom {
            display: none;
        }
    </style>
</head>
<body>

    <div class="palm-upload-container">
        <div class="palm-input-group">
            <div class="upload-box" id="leftPalmBox">
                <!-- This input will now hold a JSON string of Data URLs -->
                <input type="hidden" id="leftPalmInput" name="leftPalmPhoto" />
                <span id="leftPalmText" class="placeholder-text">Left Palm Photo *</span>
                <div class="photo-gallery" id="leftPalmGallery">
                    <!-- Captured images will be appended here -->
                </div>
            </div>
            <button class="capture-trigger-btn" data-palm="left" aria-label="Capture Left Palm"><i class="fas fa-camera"></i></button>
            <!-- Removed the main "Remove Left Palm" button -->
        </div>

        <div class="palm-input-group">
            <div class="upload-box" id="rightPalmBox">
                <!-- This input will now hold a JSON string of Data URLs -->
                <input type="hidden" id="rightPalmInput" name="rightPalmPhoto" />
                <span id="rightPalmText" class="placeholder-text">Right Palm Photo *</span>
                <div class="photo-gallery" id="rightPalmGallery">
                    <!-- Captured images will be appended here -->
                </div>
            </div>
            <button class="capture-trigger-btn" data-palm="right" aria-label="Capture Right Palm"><i class="fas fa-camera"></i></button>
            <!-- Removed the main "Remove Right Palm" button -->
        </div>
    </div>

    <!-- The Modal for Camera Application -->
    <div id="cameraModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Capture Palm Photo</h2>
                <button class="modal-close-btn" id="closeModalBtn" aria-label="Close Camera"><i class="fas fa-times"></i></button>
            </div>
            <div class="camera-area">
                <video id="cameraFeed" autoplay playsinline></video>
                <canvas id="hiddenCanvas"></canvas>
                <canvas id="motionDetectionCanvas"></canvas>
                <div id="handOutlineOverlay" class="hand-outline-overlay red-outline"></div>
                <canvas id="drawingCanvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></canvas>
                <!-- Message box overlay on camera view -->
                <div id="cameraMessageBox" class="message-info"></div>
            </div>
            <div class="controls">
                <div class="button-group">
                    <button id="captureBtn" class="btn-capture" disabled aria-label="Capture Image"><i class="fas fa-camera"></i></button>
                    <button id="toggleCameraBtn" class="btn-secondary" aria-label="Toggle Camera"><i class="fas fa-camera-rotate"></i></button>
                    <button id="toggleAutoCaptureBtn" class="btn-toggle-auto-capture" aria-label="Toggle Auto Capture"><i class="fas fa-magic"></i></button>
                </div>
                <!-- Zoom controls group -->
                <div id="zoomControlsGroup" class="zoom-controls-group">
                    <!-- Zoom In/Out buttons removed as requested -->
                </div>
                <label for="zoomSlider" id="zoomSliderLabel" class="zoom-slider-label">Zoom Level:</label>
                <input type="range" id="zoomSlider" min="0" max="100" value="0" class="w-full" disabled>
            </div>
        </div>
    </div>

    <script>
        // --- Cloudinary Configuration ---
        const CLOUDINARY_CLOUD_NAME = 'dazdmk8zp';
        const CLOUDINARY_UPLOAD_PRESET = 'palm_uploads';

        // --- DOM Elements ---
        const cameraModal = document.getElementById('cameraModal');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const modalTitle = document.getElementById('modalTitle');
        const captureTriggerButtons = document.querySelectorAll('.palm-input-group .capture-trigger-btn');
        // Removed direct reference to main remove buttons as they are removed from HTML
        // const removeImageButtons = document.querySelectorAll('.palm-input-group .remove-image-btn'); 

        const cameraFeed = document.getElementById('cameraFeed');
        const zoomInBtn = document.getElementById('zoomInBtn'); /* Kept for JS reference, but removed from HTML */
        const zoomOutBtn = document.getElementById('zoomOutBtn'); /* Kept for JS reference, but removed from HTML */
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomSliderLabel = document.getElementById('zoomSliderLabel');
        const zoomControlsGroup = document.getElementById('zoomControlsGroup');

        const cameraMessageBox = document.getElementById('cameraMessageBox');
        const handOutlineOverlay = document.getElementById('handOutlineOverlay');
        const drawingCanvas = document.getElementById('drawingCanvas');
        const drawingCtx = drawingCanvas.getContext('2d');
        const hiddenCanvas = document.getElementById('hiddenCanvas');
        const ctx = hiddenCanvas.getContext('2d');
        const motionDetectionCanvas = document.getElementById('motionDetectionCanvas');
        const motionDetectionCtx = motionDetectionCanvas.getContext('2d');
        const captureBtn = document.getElementById('captureBtn');
        const toggleCameraBtn = document.getElementById('toggleCameraBtn');
        const toggleAutoCaptureBtn = document.getElementById('toggleAutoCaptureBtn');

        // References for left palm elements
        const leftPalmInput = document.getElementById('leftPalmInput');
        const leftPalmText = document.getElementById('leftPalmText');
        const leftPalmGallery = document.getElementById('leftPalmGallery');

        // References for right palm elements
        const rightPalmInput = document.getElementById('rightPalmInput');
        const rightPalmText = document.getElementById('rightPalmText');
        const rightPalmGallery = document.getElementById('rightPalmGallery');

        // --- Planet Data ---
        const planets = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'];
        let selectedPlanets = [];

        // --- State Variables ---
        let mediaStream = null;
        let videoTrack = null;
        let zoomCapabilities = null;
        let currentZoom = 0;
        let isHandDetected = false;
        let lightingCondition = 'unknown'; // 'good', 'low', 'high', 'poor_contrast'
        let isHandSteady = true;
        let isFocused = false; // New: Track focus status
        let handposeModel = null;
        let currentPalmTarget = null;
        let animationFrameId = null;
        let currentFacingMode = 'user'; // 'user' for front camera, 'environment' for back camera

        let isAutoCaptureActive = false;
        const autoCaptureCooldown = 3000; // 3 seconds cooldown between auto-captures
        let lastAutoCaptureTime = 0;
        let scanCompletionTimeoutId = null;
        const scanDuration = 1500; // 1.5 seconds

        // Motion detection variables
        let lastFrameData = null;
        const MOTION_THRESHOLD = 5000000; // Significantly increased threshold

        // Focus detection variables
        const SHARPNESS_THRESHOLD = 0; // Adjust this value based on testing for desired sharpness

        // Arrays to store captured image Data URLs for each palm (will be uploaded by footer script)
        let leftPalmPhotos = [];
        let rightPalmPhotos = [];

        // Lighting thresholds (adjust as needed for your environment)
        const LOW_BRIGHTNESS_THRESHOLD = 60;
        const HIGH_BRIGHTNESS_THRESHOLD = 180;
        const MIN_CONTRAST_THRESHOLD = 30;

        // --- Utility Functions ---

        /**
         * Sanitizes email for use as a folder name.
         * @param {string} email - The email address to sanitize.
         * @returns {string} The sanitized string.
         */
        function sanitizeEmailForFolder(email) {
            let sanitized = email.replace(/[^a-zA-Z0-9@.]/g, '_').toLowerCase();
            sanitized = sanitized.replace(/\./g, '_').replace(/@/g, '__');
            return sanitized;
        }

        function selectRandomPlanets() {
            const shuffled = planets.sort(() => 0.5 - Math.random());
            selectedPlanets = shuffled.slice(0, 5).map(name => ({
                name,
                x: Math.random() * drawingCanvas.width,
                y: Math.random() * drawingCanvas.height,
                image: new Image()
            }));
            selectedPlanets.forEach(planet => {
                planet.image.src = `https://via.placeholder.com/50?text=${planet.name}`;
            });
        }

        /**
         * Displays a message in the camera message box.
         * @param {string} message - The message to display.
         * @param {string} type - The type of message ('info', 'warning', 'error', 'success').
         */
        function updateMessageBox(message, type = 'info') {
            cameraMessageBox.textContent = message;
            cameraMessageBox.style.display = 'block';
            cameraMessageBox.className = `message-box ${type}`; // Use the new class names
        }

        /**
         * Initializes the camera feed and sets up zoom controls.
         */
        async function initCamera() {
            try {
                stopCamera();

                const videoConstraints = {
                    facingMode: currentFacingMode
                };

                mediaStream = await navigator.mediaDevices.getUserMedia({ video: videoConstraints });
                cameraFeed.srcObject = mediaStream;

                cameraFeed.style.transform = (currentFacingMode === 'user') ? 'scaleX(-1)' : 'none';

                videoTrack = mediaStream.getVideoTracks()[0];

                const capabilities = videoTrack.getCapabilities();
                if (capabilities.zoom) {
                    zoomCapabilities = capabilities.zoom;
                    zoomSlider.min = zoomCapabilities.min;
                    zoomSlider.max = zoomCapabilities.max;
                    zoomSlider.step = zoomCapabilities.step;
                    currentZoom = zoomCapabilities.min;
                    zoomSlider.value = currentZoom;
                    zoomControlsGroup.classList.remove('hidden-zoom');
                    zoomSliderLabel.classList.remove('hidden-zoom');
                    zoomSlider.classList.remove('hidden-zoom');
                    zoomSlider.disabled = false;
                    updateZoomDisplay();
                    updateMessageBox('Camera ready. Zoom controls available.', 'info');
                } else {
                    updateMessageBox('Zoom is not supported by your camera or browser.', 'warning');
                    zoomControlsGroup.classList.add('hidden-zoom');
                    zoomSliderLabel.classList.add('hidden-zoom');
                    zoomSlider.classList.add('hidden-zoom');
                    zoomSlider.disabled = true;
                }
                updateHandOutline();
                checkCaptureButtonState();

                cameraFeed.onloadedmetadata = () => {
                    motionDetectionCanvas.width = cameraFeed.videoWidth;
                    motionDetectionCanvas.height = cameraFeed.videoHeight;
                    startDetectionLoop();
                };

            }
            catch (error) {
                console.error('Error accessing camera:', error);
                if (error.name === 'NotAllowedError') {
                    updateMessageBox('Camera access denied. Please allow camera access in your browser settings.', 'error');
                } else if (error.name === 'NotFoundError') {
                    updateMessageBox('No camera found on your device.', 'error');
                } else if (error.name === 'OverconstrainedError') {
                    updateMessageBox('Requested camera not available. Trying default camera.', 'warning');
                    currentFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user';
                    initCamera();
                }
                else {
                    updateMessageBox(`Error: ${error.message}. Could not access camera.`, 'error');
                }
                zoomControlsGroup.classList.add('hidden-zoom');
                zoomSliderLabel.classList.add('hidden-zoom');
                zoomSlider.classList.add('hidden-zoom');
                zoomSlider.disabled = true;
                captureBtn.disabled = true;
            }
        }

        /**
         * Stops the camera feed and cancels the animation loop.
         */
        function stopCamera() {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => {
                    track.stop();
                });
                cameraFeed.srcObject = null;
                mediaStream = null;
                videoTrack = null;
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            if (scanCompletionTimeoutId) {
                clearTimeout(scanCompletionTimeoutId);
                scanCompletionTimeoutId = null;
            }
            lastFrameData = null;
            isHandSteady = true;
            isFocused = false; // Reset focus state
        }

        /**
         * Applies the new zoom level to the video track.
         * @param {number} newZoom - The desired zoom level.
         */
        function applyZoom(newZoom) {
            if (!videoTrack || !zoomCapabilities) {
                updateMessageBox('Camera not ready or zoom not supported.', 'warning');
                return;
            }

            newZoom = Math.max(zoomCapabilities.min, Math.min(newZoom, zoomCapabilities.max));

            videoTrack.applyConstraints({
                advanced: [{ zoom: newZoom }]
            }).then(() => {
                currentZoom = newZoom;
                zoomSlider.value = currentZoom;
                updateZoomDisplay();
            }).catch(error => {
                console.error('Error applying zoom:', error);
                updateMessageBox(`Failed to apply zoom: ${error.message}`, 'error');
            });
        }

        /**
         * Updates the zoom slider and potentially a text display (if added).
         */
        function updateZoomDisplay() {
            // Placeholder
        }

        /**
         * Updates the hand outline color based on the isHandDetected state.
         */
        function updateHandOutline() {
            if (isHandDetected) {
                handOutlineOverlay.classList.remove('red-outline');
                handOutlineOverlay.classList.add('green-outline');
            } else {
                handOutlineOverlay.classList.remove('green-outline');
                handOutlineOverlay.classList.add('red-outline');
            }
            if (isHandDetected && lightingCondition === 'good' && isHandSteady && isFocused) {
                handOutlineOverlay.classList.add('scanning');
            } else {
                handOutlineOverlay.classList.remove('scanning');
            }
        }

        /**
         * Analyzes the lighting condition from the provided ImageData, including contrast.
         * @param {ImageData} imageData - The image data from the canvas.
         * @returns {string} 'good', 'low', 'high', or 'poor_contrast'.
         */
        function analyzeLighting(imageData) {
            const data = imageData.data;
            let totalLuminance = 0;
            let luminances = [];
            const pixelCount = data.length / 4;

            if (pixelCount === 0) {
                return 'unknown';
            }

            for (let i = 0; i < data.length; i += 4) {
                const luminance = (data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114);
                totalLuminance += luminance;
                luminances.push(luminance);
            }
            const averageLuminance = totalLuminance / pixelCount;

            let variance = 0;
            for (let i = 0; i < luminances.length; i++) {
                variance += Math.pow(luminances[i] - averageLuminance, 2);
            }
            const luminanceStdDev = Math.sqrt(variance / luminances.length);

            let condition;
            if (averageLuminance < LOW_BRIGHTNESS_THRESHOLD) {
                condition = 'low';
            } else if (averageLuminance > HIGH_BRIGHTNESS_THRESHOLD) {
                condition = 'high';
            } else if (luminanceStdDev < MIN_CONTRAST_THRESHOLD) {
                condition = 'poor_contrast';
            } else {
                condition = 'good';
            }
            return condition;
        }

        /**
         * Detects motion by comparing current frame pixels to the last frame.
         * It focuses on the central area of the frame to reduce background noise.
         * @param {HTMLVideoElement} video - The video element.
         * @returns {boolean} True if motion is detected, false otherwise.
         */
        function detectMotion(video) {
            if (!video.videoWidth || !video.videoHeight) {
                return false;
            }

            const regionWidth = video.videoWidth * 0.8;
            const regionHeight = video.videoHeight * 0.8;
            const regionX = (video.videoWidth - regionWidth) / 2;
            const regionY = (video.videoHeight - regionHeight) / 2;

            motionDetectionCanvas.width = regionWidth;
            motionDetectionCanvas.height = regionHeight;
            motionDetectionCtx.drawImage(video, regionX, regionY, regionWidth, regionHeight, 0, 0, regionWidth, regionHeight);
            const currentFrameData = motionDetectionCtx.getImageData(0, 0, regionWidth, regionHeight).data;

            if (!lastFrameData || lastFrameData.length !== currentFrameData.length) {
                lastFrameData = currentFrameData;
                return false;
            }

            let difference = 0;
            for (let i = 0; i < currentFrameData.length; i += 40) {
                difference += Math.abs(currentFrameData[i] - lastFrameData[i]);
                difference += Math.abs(currentFrameData[i+1] - lastFrameData[i+1]);
                difference += Math.abs(currentFrameData[i+2] - lastFrameData[i+2]);
            }
            lastFrameData = currentFrameData;

            return difference > MOTION_THRESHOLD;
        }

        /**
         * Analyzes the focus (sharpness) of the image within a given bounding box.
         * Uses Laplacian variance.
         * @param {CanvasRenderingContext2D} context - The context of the canvas containing the image.
         * @param {object} boundingBox - {x, y, width, height} of the region to analyze.
         * @returns {number} The sharpness score (variance of Laplacian). Higher is sharper.
         */
        function analyzeFocus(context, boundingBox) {
            const canvasWidth = context.canvas.width;
            const canvasHeight = context.canvas.height;

            // Clamp bounding box coordinates to canvas boundaries
            const x1 = Math.max(0, Math.floor(boundingBox.x));
            const y1 = Math.max(0, Math.floor(boundingBox.y));
            const x2 = Math.min(canvasWidth, Math.ceil(boundingBox.x + boundingBox.width));
            const y2 = Math.min(canvasHeight, Math.ceil(boundingBox.y + boundingBox.height));

            // Recalculate width and height from clamped coordinates
            const width = x2 - x1;
            const height = y2 - y1;

            // If the calculated region has zero or negative dimensions, return 0 sharpness
            if (width <= 0 || height <= 0) {
                console.warn(`[analyzeFocus] Invalid region dimensions after clamping: x1=${x1}, y1=${y1}, width=${width}, height=${height}. Returning 0 sharpness.`);
                return 0;
            }

            let imageData;
            try {
                imageData = context.getImageData(x1, y1, width, height);
            } catch (error) {
                console.error(`[analyzeFocus] Failed to get ImageData for region [${x1}, ${y1}, ${width}, ${height}]. Error:`, error);
                return 0;
            }
            
            const pixels = imageData.data;
            const grayPixels = new Float32Array(width * height);

            // Convert to grayscale
            for (let i = 0, j = 0; i < pixels.length; i += 4, j++) {
                grayPixels[j] = (pixels[i] * 0.299 + pixels[i + 1] * 0.587 + pixels[i + 2] * 0.114);
            }

            // Apply Laplacian filter (simplified 3x3 kernel)
            //  0  1  0
            //  1 -4  1
            //  0  1  0
            let sumOfSquares = 0;
            let count = 0;

            for (let row = 1; row < height - 1; row++) {
                for (let col = 1; col < width - 1; col++) {
                    const i = row * width + col;
                    const laplacian =
                        grayPixels[i - width] + // top
                        grayPixels[i + width] + // bottom
                        grayPixels[i - 1] +     // left
                        grayPixels[i + 1] -     // right
                        (4 * grayPixels[i]);    // center

                    sumOfSquares += (laplacian * laplacian);
                    count++;
                }
            }

            if (count === 0) return 0;

            const variance = sumOfSquares / count;
            return variance;
        }


        /**
         * Updates the combined status message in the message box.
         */
        function updateCombinedStatusMessage() {
            let handStatus = isHandDetected ? 'Hand detected!' : 'No hand visible.';
            let lightingStatusText = '';
            let focusStatusText = '';
            let messageType = 'info';

            switch (lightingCondition) {
                case 'low':
                    lightingStatusText = 'Lighting is too low. Move to a brighter area.';
                    messageType = 'warning';
                    break;
                case 'high':
                    lightingStatusText = 'Lighting is too bright. Avoid glare.';
                    messageType = 'warning';
                    break;
                case 'poor_contrast':
                    lightingStatusText = 'Poor contrast. Adjust lighting to see details (e.g., lines).';
                    messageType = 'warning';
                    break;
                case 'good':
                    lightingStatusText = 'Lighting looks good for details.';
                    messageType = 'success';
                    break;
                default:
                    lightingStatusText = 'Analyzing lighting...';
                    messageType = 'info';
            }

            if (isHandDetected) { // Only check focus if hand is detected
                if (isFocused) {
                    focusStatusText = 'Image is in focus.';
                    if (messageType !== 'warning') messageType = 'success'; // Prioritize warning if lighting is bad
                } else {
                    focusStatusText = 'Image is blurry, adjust focus.';
                    messageType = 'warning'; // Focus issue is a warning
                }
            }

            let motionStatusText = isHandSteady ? '' : 'Hold hand steady.';
            if (!isHandSteady) {
                messageType = 'warning';
            }

            const messages = [handStatus, lightingStatusText, focusStatusText, motionStatusText].filter(Boolean); // Remove empty strings
            const fullMessage = messages.join(' ').trim();
            updateMessageBox(fullMessage, messageType);
        }

        /**
         * Enables or disables the capture button based on hand detection, lighting, stability, and focus.
         */
        function checkCaptureButtonState() {
            const canCapture = isHandDetected && lightingCondition === 'good' && isHandSteady && isFocused;
            captureBtn.disabled = !canCapture;
        }

        /**
         * Loads the Handpose model.
         */
        async function loadHandposeModel() {
            updateMessageBox('Loading hand detection model...', 'info');
            try {
                handposeModel = await handpose.load();
                updateMessageBox('Hand detection model loaded successfully!', 'info');
            } catch (error) {
                console.error('Error loading handpose model:', error);
                updateMessageBox('Failed to load hand detection model. Hand detection will not work.', 'error');
            }
        }

        /**
         * Starts the continuous hand and lighting detection loop.
         */
        async function startDetectionLoop() {
            if (!handposeModel || !cameraFeed.videoWidth || !cameraFeed.videoHeight || !mediaStream) {
                animationFrameId = requestAnimationFrame(startDetectionLoop);
                return;
            }

            isHandSteady = !detectMotion(cameraFeed);

            // Draw the video frame onto the hidden canvas for ML and image analysis
            // Use the video's native dimensions for accurate pixel data for analysis
            hiddenCanvas.width = cameraFeed.videoWidth;
            hiddenCanvas.height = cameraFeed.videoHeight;
            drawingCanvas.width = cameraFeed.videoWidth;
            drawingCanvas.height = cameraFeed.videoHeight;
            drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            ctx.drawImage(cameraFeed, 0, 0, hiddenCanvas.width, hiddenCanvas.height);
            
            const imageData = ctx.getImageData(0, 0, hiddenCanvas.width, hiddenCanvas.height);
            lightingCondition = analyzeLighting(imageData);

            const predictions = await handposeModel.estimateHands(hiddenCanvas);
            const handPreviouslyDetected = isHandDetected;
            isHandDetected = predictions.length > 0;

            if (isHandDetected && !handPreviouslyDetected) {
                selectRandomPlanets();
            } else if (!isHandDetected && handPreviouslyDetected) {
                selectedPlanets = [];
            }

            if (isHandDetected && predictions[0] && predictions[0].boundingBox) { // Ensure prediction and bounding box exist
                const landmarks = predictions[0].landmarks;
                const fingertips = [
                    landmarks[4], // Thumb
                    landmarks[8], // Index
                    landmarks[12], // Middle
                    landmarks[16], // Ring
                    landmarks[20]  // Pinky
                ];

                const bbox = predictions[0].boundingBox;
                // Round the bounding box coordinates to integers
                let handBoundingBox = {
                    x: Math.round(bbox.topLeft[0][0]),
                    y: Math.round(bbox.topLeft[0][1]),
                    width: Math.round(bbox.bottomRight[0][0] - bbox.topLeft[0][0]),
                    height: Math.round(bbox.bottomRight[0][1] - bbox.topLeft[0][1])
                };

                const sharpnessScore = analyzeFocus(ctx, handBoundingBox);
                isFocused = sharpnessScore >= SHARPNESS_THRESHOLD;
                console.log(`Sharpness Score: ${sharpnessScore.toFixed(2)}, Focused: ${isFocused}`); // Log sharpness score

                if (selectedPlanets.length > 0 && landmarks.length > 20) {
                    const palmBase = landmarks[0];
                    const wrist = landmarks[0];

                    fingertips.forEach((fingertip, i) => {
                        if (selectedPlanets[i] && fingertip) {
                            const fingerMCP = landmarks[i * 4 + 1];

                            let vecX = fingertip[0] - fingerMCP[0];
                            let vecY = fingertip[1] - fingerMCP[1];

                            const length = Math.sqrt(vecX * vecX + vecY * vecY);
                            if (length > 0) {
                                vecX /= length;
                                vecY /= length;
                            }

                            const lineLength = 150;
                            const planetX = fingertip[0] + vecX * lineLength;
                            const planetY = fingertip[1] + vecY * lineLength;
                            const planetSize = 50;

                            drawingCtx.beginPath();
                            drawingCtx.moveTo(fingertip[0], fingertip[1]);
                            drawingCtx.lineTo(planetX, planetY);
                            drawingCtx.strokeStyle = 'white';
                            drawingCtx.lineWidth = 2;
                            drawingCtx.stroke();

                            drawingCtx.drawImage(selectedPlanets[i].image, planetX - planetSize / 2, planetY - planetSize / 2, planetSize, planetSize);
                        }
                    });
                }
            } else {
                isFocused = false; // Not focused if no hand detected or no valid bounding box
            }


            updateHandOutline();
            updateCombinedStatusMessage();
            checkCaptureButtonState();

            if (isAutoCaptureActive) {
                const now = Date.now();
                const canCaptureNow = (now - lastAutoCaptureTime > autoCaptureCooldown);

                // Auto-capture condition now includes isFocused
                if (isHandDetected && lightingCondition === 'good' && isHandSteady && isFocused) {
                    if (!scanCompletionTimeoutId && canCaptureNow) {
                        updateMessageBox('Scanning... Hold hand steady and in focus.', 'info');
                        scanCompletionTimeoutId = setTimeout(() => {
                            // Re-check all conditions before final capture
                            if (isHandDetected && lightingCondition === 'good' && isHandSteady && isFocused) {
                                captureImage();
                                lastAutoCaptureTime = Date.now();
                            } else {
                                updateMessageBox('Scan interrupted. Conditions changed or hand moved/blurred.', 'warning');
                            }
                            scanCompletionTimeoutId = null;
                        }, scanDuration);
                    }
                } else {
                    if (scanCompletionTimeoutId) {
                        clearTimeout(scanCompletionTimeoutId);
                        scanCompletionTimeoutId = null;
                        updateMessageBox('Scan cancelled. Adjust hand, lighting, focus, or hold steady.', 'warning');
                    }
                }
            } else {
                if (scanCompletionTimeoutId) {
                    clearTimeout(scanCompletionTimeoutId);
                    scanCompletionTimeoutId = null;
                }
            }

            animationFrameId = requestAnimationFrame(startDetectionLoop);
        }

        /**
         * Applies a simple contrast/sharpening filter to the canvas context.
         * @param {CanvasRenderingContext2D} context - The 2D context of the canvas.
         * @param {number} amount - The intensity of the filter.
         */
        function applyContrastFilter(context, amount) {
            const imageData = context.getImageData(0, 0, context.canvas.width, context.canvas.height);
            const pixels = imageData.data;
            const factor = (259 * (amount + 255)) / (255 * (259 - amount));

            for (let i = 0; i < pixels.length; i += 4) {
                pixels[i] = factor * (pixels[i] - 128) + 128;
                pixels[i + 1] = factor * (pixels[i + 1] - 128) + 128;
                pixels[i + 2] = factor * (pixels[i + 2] - 128) + 128;
            }
            context.putImageData(imageData, 0, 0);
        }


        /**
         * Captures the current frame from the camera feed, processes it,
         * and uploads to Cloudinary.
         */
        async function captureImage() {
            const userEmailInput = document.querySelector('#field-419c2e1a');
            const userEmail = userEmailInput ? userEmailInput.value : 'test@example.com';

            if (!userEmail) {
                updateMessageBox('Please enter your email address before capturing photos.', 'error');
                captureBtn.disabled = false;
                return;
            }

            if (!cameraFeed.srcObject) {
                updateMessageBox('Camera not active. Cannot capture image.', 'error');
                captureBtn.disabled = false;
                return;
            }
            // Ensure all conditions are met for capture
            if (!isHandDetected || lightingCondition !== 'good' || !isHandSteady || !isFocused) {
                 if (!isAutoCaptureActive) { // Only show specific warning for manual capture if conditions aren't met
                    updateMessageBox('Cannot capture: Hand not detected, lighting is poor, hand is moving, or image is out of focus.', 'warning');
                 }
                captureBtn.disabled = false;
                return;
            }


            updateMessageBox('Capturing and uploading image...', 'info');
            captureBtn.disabled = true; // Disable capture button during upload

            try {
                const videoNativeWidth = cameraFeed.videoWidth;
                const videoNativeHeight = cameraFeed.videoHeight;
                
                // Define target capture resolution (2K / QHD)
                const TARGET_CAPTURE_WIDTH = 2560; // 2K width
                const TARGET_CAPTURE_HEIGHT = 1440; // 2K height (1440p)

                // Determine target canvas dimensions based on display orientation
                const isDisplayLandscape = window.innerWidth > window.innerHeight; // Check actual window orientation
                let targetCanvasWidth, targetCanvasHeight;

                if (isDisplayLandscape) {
                    targetCanvasWidth = TARGET_CAPTURE_WIDTH;
                    targetCanvasHeight = TARGET_CAPTURE_HEIGHT;
                } else {
                    // If display is portrait, swap target dimensions
                    targetCanvasWidth = TARGET_CAPTURE_HEIGHT;
                    targetCanvasHeight = TARGET_CAPTURE_WIDTH;
                }

                hiddenCanvas.width = targetCanvasWidth;
                hiddenCanvas.height = targetCanvasHeight;
                ctx.clearRect(0, 0, hiddenCanvas.width, hiddenCanvas.height);

                const tempRawCanvas = document.createElement('canvas');
                const tempRawCtx = tempRawCanvas.getContext('2d');
                tempRawCanvas.width = videoNativeWidth;
                tempRawCanvas.height = videoNativeHeight;
                tempRawCtx.drawImage(cameraFeed, 0, 0, videoNativeWidth, videoNativeHeight);

                const isRawVideoPortrait = videoNativeHeight > videoNativeWidth;
                const needsRotation = (isRawVideoPortrait && isDisplayLandscape) || (!isRawVideoPortrait && !isDisplayLandscape);

                let sourceForCropping = tempRawCanvas;
                let sourceForCroppingWidth = videoNativeWidth;
                let sourceForCroppingHeight = videoNativeHeight;

                if (needsRotation) {
                    const rotatedSourceCanvas = document.createElement('canvas');
                    const rotatedSourceCtx = rotatedSourceCanvas.getContext('2d');
                    rotatedSourceCanvas.width = videoNativeHeight; // Swapped dimensions
                    rotatedSourceCanvas.height = videoNativeWidth;

                    rotatedSourceCtx.save();
                    rotatedSourceCtx.translate(rotatedSourceCanvas.width / 2, rotatedSourceCanvas.height / 2);
                    rotatedSourceCtx.rotate(90 * Math.PI / 180); // Rotate 90 degrees clockwise
                    rotatedSourceCtx.drawImage(tempRawCanvas, -videoNativeWidth / 2, -videoNativeHeight / 2, videoNativeWidth, videoNativeHeight);
                    rotatedSourceCtx.restore();

                    sourceForCropping = rotatedSourceCanvas;
                    sourceForCroppingWidth = rotatedSourceCanvas.width;
                    sourceForCroppingHeight = rotatedSourceCanvas.height;
                }

                const sourceAspectRatio = sourceForCroppingWidth / sourceForCroppingHeight;
                const targetAspectRatio = targetCanvasWidth / targetCanvasHeight;

                let sx = 0, sy = 0;
                let sCropWidth = sourceForCroppingWidth;
                let sCropHeight = sourceForCroppingHeight;

                if (sourceAspectRatio > targetAspectRatio) {
                    // Source is wider than target aspect ratio, crop horizontally
                    sCropHeight = sourceForCroppingHeight;
                    sCropWidth = sCropHeight * targetAspectRatio;
                    sx = (sourceForCroppingWidth - sCropWidth) / 2;
                    sy = 0;
                } else {
                    // Source is taller than or same aspect ratio as target, crop vertically
                    sCropWidth = sourceForCroppingWidth;
                    sCropHeight = sCropWidth / targetAspectRatio;
                    sy = (sourceForCroppingHeight - sCropHeight) / 2;
                    sx = 0;
                }

                ctx.save();
                if (currentFacingMode === 'user') {
                    ctx.translate(hiddenCanvas.width, 0);
                    ctx.scale(-1, 1);
                }
                // Draw the cropped and oriented source onto the fixed-size hiddenCanvas
                ctx.drawImage(sourceForCropping, sx, sy, sCropWidth, sCropHeight, 0, 0, hiddenCanvas.width, hiddenCanvas.height);
                ctx.restore();

                applyContrastFilter(ctx, 25);

                const imageDataUrl = hiddenCanvas.toDataURL('image/png');

                // --- Upload to Cloudinary ---
                const sanitizedFolderName = sanitizeEmailForFolder(userEmail);
                const randomString = Math.random().toString(36).substring(2, 8); 
                const palmTypePrefix = currentPalmTarget === 'left' ? 'left_hand' : 'right_hand';
                const uploadFolder = `${sanitizedFolderName}/${palmTypePrefix}_${randomString}`;
                console.log(`[Cloudinary Upload] Uploading to folder: ${uploadFolder}`);

                const formData = new FormData();
                formData.append('file', imageDataUrl);
                formData.append('upload_preset', CLOUDINARY_UPLOAD_PRESET);
                formData.append('cloud_name', CLOUDINARY_CLOUD_NAME);
                formData.append('folder', uploadFolder);
                formData.append('public_id', `${palmTypePrefix}_${Date.now()}`);

                const uploadResponse = await fetch(`https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD_NAME}/image/upload`, {
                    method: 'POST',
                    body: formData
                });

                const uploadResult = await uploadResponse.json();
                console.log("[Cloudinary Upload] Response:", uploadResult);

                if (uploadResult.secure_url) {
                    const imageUrl = uploadResult.secure_url;
                    console.log("[Cloudinary Upload] Success! URL:", imageUrl);

                    if (currentPalmTarget === 'left') {
                        leftPalmPhotos.push(imageUrl);
                        renderPhotos('left');
                    } else if (currentPalmTarget === 'right') {
                        rightPalmPhotos.push(imageUrl);
                        renderPhotos('right');
                    }

                    updateMessageBox('Image captured and uploaded successfully!', 'success');
                } else {
                    console.error('[Cloudinary Upload] Failed:', uploadResult);
                    updateMessageBox(`Image upload failed: ${uploadResult.error.message || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                console.error('[Cloudinary Upload] Error during capture or upload:', error);
                updateMessageBox(`Error capturing or uploading image: ${error.message}`, 'error');
            } finally {
                captureBtn.disabled = false;
            }
			closeCameraModal();
        }

        /**
         * Renders the photos for a given palm into its gallery.
         * @param {string} palm - 'left' or 'right'.
         */
        function renderPhotos(palm) {
            let galleryElement, photosArray, textElement, inputElement;

            if (palm === 'left') {
                galleryElement = leftPalmGallery;
                photosArray = leftPalmPhotos;
                textElement = leftPalmText;
                inputElement = leftPalmInput;
            } else if (palm === 'right') {
                galleryElement = rightPalmGallery;
                photosArray = rightPalmPhotos;
                textElement = rightPalmText;
                inputElement = rightPalmInput;
            }

            galleryElement.innerHTML = '';

            if (photosArray.length === 0) {
                textElement.style.display = 'flex';
            } else {
                textElement.style.display = 'none';
                photosArray.forEach((url, index) => {
                    const photoCard = document.createElement('div');
                    photoCard.classList.add('photo-card');
                    photoCard.dataset.index = index;

                    const img = document.createElement('img');
                    img.src = url;
                    img.alt = `${palm} Palm Photo ${index + 1}`;

                    const deleteBtn = document.createElement('button');
                    deleteBtn.classList.add('delete-photo-btn');
                    deleteBtn.textContent = 'x';
                    deleteBtn.title = 'Remove photo (local only)';
                    deleteBtn.addEventListener('click', (event) => {
                        event.stopPropagation();
                        removePhoto(palm, index);
                    });

                    photoCard.appendChild(img);
                    photoCard.appendChild(deleteBtn);
                    galleryElement.appendChild(photoCard);
                });
            }
            inputElement.value = JSON.stringify(photosArray);
        }

        /**
         * Removes a specific photo from the gallery and updates the data.
         * @param {string} palm - 'left' or 'right'.
         * @param {number} index - The index of the photo to remove.
         */
        function removePhoto(palm, index) {
            let photosArray;
            if (palm === 'left') {
                photosArray = leftPalmPhotos;
            } else if (palm === 'right') {
                photosArray = rightPalmPhotos;
            }

            if (index > -1 && index < photosArray.length) {
                photosArray.splice(index, 1);
                renderPhotos(palm);
                updateMessageBox(`${palm === 'left' ? 'Left' : 'Right'} palm photo removed (local only). Note: Image remains on Cloudinary.`, 'info');
            } else {
            }
        }

        // --- Modal Control Functions ---

        /**
         * Opens the camera modal and initializes the camera.
         * @param {string} palm - 'left' or 'right' to indicate which palm is being captured.
         */
        async function openCameraModal(palm) {
            currentPalmTarget = palm;
            modalTitle.textContent = `Capture ${palm === 'left' ? 'Left' : 'Right'} Palm Photo`;
            cameraModal.classList.add('show');
            await initCamera();
        }

        /**
         * Closes the camera modal and stops the camera.
         */
        function closeCameraModal() {
            cameraModal.classList.remove('show');
            stopCamera();
            currentPalmTarget = null;
            updateMessageBox('', 'info');
        }

        // --- Event Listeners ---

        captureTriggerButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                const palm = event.currentTarget.dataset.palm;
                openCameraModal(palm);
            });
        });

        closeModalBtn.addEventListener('click', () => {
            closeModalBtn.disabled = true;
            closeCameraModal();
            setTimeout(() => closeModalBtn.disabled = false, 500);
        });

        zoomSlider.addEventListener('input', (event) => {
            if (zoomCapabilities) {
                const newZoom = parseFloat(event.target.value);
                applyZoom(newZoom);
            }
        });

        captureBtn.addEventListener('click', () => {
            captureImage();
        });

        toggleCameraBtn.addEventListener('click', () => {
            currentFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user';
            initCamera();
        });

        toggleAutoCaptureBtn.addEventListener('click', () => {
            isAutoCaptureActive = !isAutoCaptureActive;
            if (isAutoCaptureActive) {
                toggleAutoCaptureBtn.classList.add('active');
                toggleAutoCaptureBtn.innerHTML = '<i class="fas fa-magic"></i>'; // Icon only
                toggleAutoCaptureBtn.setAttribute('aria-label', 'Auto Capture: ON'); // Accessibility
                lastAutoCaptureTime = 0;
                updateMessageBox('Auto capture is ON. Position hand for capture.', 'info');
            } else {
                toggleAutoCaptureBtn.classList.remove('active');
                toggleAutoCaptureBtn.innerHTML = '<i class="fas fa-magic"></i>'; // Icon only
                toggleAutoCaptureBtn.setAttribute('aria-label', 'Auto Capture: OFF'); // Accessibility
                updateMessageBox('Auto capture is OFF. Use manual capture button.', 'info');
            }
        });


        // --- Initial Load ---
        window.onload = async () => {
            await loadHandposeModel();
            renderPhotos('left');
            renderPhotos('right');
        };

        window.addEventListener('beforeunload', () => {
            stopCamera();
        });
    </script>
</body>
</html>
