<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Palm Photo Capture with Custom Camera</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- TensorFlow.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <!-- MediaPipe Hands CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js"></script>
    <!-- HandPose model from TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose@0.0.7/dist/handpose.min.js"></script>

    <style>
        /* Custom styles for better visual appeal */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px; /* Add some padding for smaller screens */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }

        /* User's original palm upload container styles */
        .palm-upload-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }
        /* New container for each palm box and its buttons */
        .palm-input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px; /* Space between box and buttons */
        }

        .upload-box {
            border: 2px dashed #d7bfb9;
            border-radius: 8px;
            width: 180px;
            height: 180px; /* Increased height to accommodate image */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            background-color: #fffaf8;
            font-family: sans-serif;
            font-size: 14px;
            color: #7a3e2f;
            text-align: center;
            position: relative; /* For positioning captured image */
            overflow: hidden; /* Hide overflow for rounded corners */
            padding: 10px; /* Add padding inside the box */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }
        .upload-box span {
            margin-top: 10px;
            display: block; /* Ensure span takes full width */
            padding: 0 5px; /* Add padding to text */
            flex-grow: 1; /* Allow text to take available space */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .upload-box img {
            max-width: 100%; /* Ensure image fits */
            max-height: 100%; /* Ensure image fits */
            object-fit: contain; /* Contain the image within the box */
            border-radius: 8px;
            display: none; /* Hidden by default */
            /* No margin-bottom here, as buttons are outside */
        }
        /* Styles for the buttons now they are outside the box */
        button.capture-trigger-btn,
        button.remove-image-btn {
            background-color: #4f46e5;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.06);
            border: none;
            flex-shrink: 0;
            width: 100%; /* Make buttons full width of the group */
            max-width: 180px; /* Match upload-box width */
        }
        button.capture-trigger-btn:hover,
        button.remove-image-btn:hover {
            background-color: #4338ca;
            transform: translateY(-1px);
        }
        button.remove-image-btn {
            background-color: #ef4444; /* Red color for remove button */
        }
        button.remove-image-btn:hover {
            background-color: #dc2626;
        }

        /* Modal specific styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .modal.show {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.08);
            max-width: 95vw; /* Responsive width for modal */
            width: 500px; /* Max width for desktop */
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .modal-header {
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e5e7eb;
        }
        .modal-header h2 {
            font-size: 1.25rem;
            font-weight: 700;
            color: #374151;
        }
        .modal-close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6b7280;
            transition: color 0.2s;
        }
        .modal-close-btn:hover {
            color: #1f2937;
        }

        /* Camera app specific styles (from previous version, adapted for modal) */
        .camera-area {
            position: relative;
            width: 100%;
            /* Default to landscape 4:3 aspect ratio for desktop */
            padding-top: 75%; /* (height / width) * 100% = (3/4) * 100% */
            overflow: hidden;
            background-color: #000;
        }

        /* Adjust for mobile portrait (e.g., up to 768px width) */
        @media (max-width: 768px) {
            .camera-area {
                /* For portrait, use a 3:4 aspect ratio (height > width) */
                padding-top: 133.33%; /* (4/3) * 100% */
            }
        }

        video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            /* transform: scaleX(-1); This will be set dynamically by JS */
        }
        #hiddenCanvas {
            display: none;
        }
        .hand-outline-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%; /* Changed from 60% to 90% */
            height: 90%; /* Changed from 60% to 90% */
            border: 4px solid;
            border-radius: 1rem;
            pointer-events: none;
            transition: border-color 0.3s ease-in-out;
        }
        .red-outline {
            border-color: #ef4444;
        }
        .green-outline {
            border-color: #22c55e;
        }
        .controls {
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .button-group {
            display: flex;
            justify-content: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: none;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.06), 0 1px 2px -1px rgba(0, 0, 0, 0.04);
        }
        .btn-primary {
            background-color: #4f46e5;
            color: white;
        }
        .btn-primary:hover {
            background-color: #4338ca;
        }
        .btn-secondary {
            background-color: #e5e7eb;
            color: #374151;
        }
        .btn-secondary:hover {
            background-color: #d1d5db;
        }
        .btn-capture {
            background-color: #10b981;
            color: white;
        }
        .btn-capture:hover {
            background-color: #059669;
        }
        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 8px;
            background: #e0e7ff;
            border-radius: 5px;
            outline: none;
            transition: opacity .2s;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4f46e5;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4f46e5;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        #message-box {
            padding: 0.75rem;
            border-radius: 0.5rem;
            text-align: center;
            font-size: 0.875rem;
            display: none;
            margin-bottom: 0.5rem;
        }
        .message-info {
            background-color: #e0e7ff;
            color: #4f46e5;
        }
        .message-warning {
            background-color: #fffbeb;
            color: #f59e0b;
        }
        .message-error {
            background-color: #fef2f2;
            color: #ef4444;
        }
        .message-success {
            background-color: #ecfdf5;
            color: #10b981;
        }
    </style>
</head>
<body>

    <div class="palm-upload-container">
        <div class="palm-input-group">
            <div class="upload-box" id="leftPalmBox">
                <input type="hidden" id="leftPalmInput" name="leftPalmPhoto" />
                <img id="leftPalmPreview" src="" alt="Left Palm Preview">
                <span id="leftPalmText">Left Palm Photo *</span>
            </div>
            <button class="capture-trigger-btn" data-palm="left">Capture Left Palm</button>
            <button class="remove-image-btn hidden" data-palm="left">Remove Left Palm</button>
        </div>

        <div class="palm-input-group">
            <div class="upload-box" id="rightPalmBox">
                <input type="hidden" id="rightPalmInput" name="rightPalmPhoto" />
                <img id="rightPalmPreview" src="" alt="Right Palm Preview">
                <span id="rightPalmText">Right Palm Photo *</span>
            </div>
            <button class="capture-trigger-btn" data-palm="right">Capture Right Palm</button>
            <button class="remove-image-btn hidden" data-palm="right">Remove Right Palm</button>
        </div>
    </div>

    <!-- The Modal for Camera Application -->
    <div id="cameraModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Capture Palm Photo</h2>
                <button class="modal-close-btn" id="closeModalBtn">&times;</button>
            </div>
            <div class="camera-area">
                <video id="cameraFeed" autoplay playsinline></video>
                <canvas id="hiddenCanvas"></canvas>
                <div id="handOutlineOverlay" class="hand-outline-overlay red-outline"></div>
            </div>
            <div class="controls">
                <div id="message-box" class="message-info"></div>
                <div class="button-group">
                    <button id="zoomOutBtn" class="btn-secondary">Zoom Out</button>
                    <button id="zoomInBtn" class="btn-primary">Zoom In</button>
                    <button id="captureBtn" class="btn-capture" disabled>Capture Image</button>
                    <button id="toggleCameraBtn" class="btn-secondary">Toggle Camera</button>
                </div>
                <label for="zoomSlider" class="text-center text-gray-700 font-medium">Zoom Level:</label>
                <input type="range" id="zoomSlider" min="0" max="100" value="0" class="w-full" disabled>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const cameraModal = document.getElementById('cameraModal');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const modalTitle = document.getElementById('modalTitle');
        // Select buttons by class, now they are direct children of palm-input-group
        const captureTriggerButtons = document.querySelectorAll('.palm-input-group .capture-trigger-btn');
        const removeImageButtons = document.querySelectorAll('.palm-input-group .remove-image-btn');

        const cameraFeed = document.getElementById('cameraFeed');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomSlider = document.getElementById('zoomSlider');
        const messageBox = document.getElementById('message-box');
        const handOutlineOverlay = document.getElementById('handOutlineOverlay');
        const hiddenCanvas = document.getElementById('hiddenCanvas');
        const ctx = hiddenCanvas.getContext('2d');
        const captureBtn = document.getElementById('captureBtn');
        const toggleCameraBtn = document.getElementById('toggleCameraBtn');

        // References for left palm elements
        const leftPalmInput = document.getElementById('leftPalmInput');
        const leftPalmPreview = document.getElementById('leftPalmPreview');
        const leftPalmText = document.getElementById('leftPalmText');
        const leftPalmRemoveBtn = document.querySelector('#leftPalmBox + .capture-trigger-btn + .remove-image-btn'); // Select by sibling

        // References for right palm elements
        const rightPalmInput = document.getElementById('rightPalmInput');
        const rightPalmPreview = document.getElementById('rightPalmPreview');
        const rightPalmText = document.getElementById('rightPalmText');
        const rightPalmRemoveBtn = document.querySelector('#rightPalmBox + .capture-trigger-btn + .remove-image-btn'); // Select by sibling

        // --- State Variables ---
        let mediaStream = null;
        let videoTrack = null;
        let zoomCapabilities = null;
        let currentZoom = 0;
        let isHandDetected = false;
        let lightingCondition = 'unknown';
        let handposeModel = null;
        let currentPalmTarget = null;
        let animationFrameId = null;
        let currentFacingMode = 'user'; // 'user' for front camera, 'environment' for back camera

        // Lighting thresholds (adjust as needed for your environment)
        const LOW_BRIGHTNESS_THRESHOLD = 60;
        const HIGH_BRIGHTNESS_THRESHOLD = 180;

        // --- Utility Functions ---

        /**
         * Displays a message in the message box.
         * @param {string} message - The message to display.
         * @param {string} type - The type of message ('info', 'warning', 'error', 'success').
         */
        function updateMessageBox(message, type = 'info') {
            messageBox.textContent = message;
            messageBox.style.display = 'block';
            messageBox.className = `message-box message-${type}`;
        }

        /**
         * Initializes the camera feed and sets up zoom controls.
         */
        async function initCamera() {
            try {
                // Stop any existing camera stream first
                stopCamera();

                // Set video constraints based on current facing mode
                const videoConstraints = {
                    facingMode: currentFacingMode
                };

                mediaStream = await navigator.mediaDevices.getUserMedia({ video: videoConstraints });
                cameraFeed.srcObject = mediaStream;

                // Apply mirroring for front camera, remove for back camera
                cameraFeed.style.transform = (currentFacingMode === 'user') ? 'scaleX(-1)' : 'none';

                videoTrack = mediaStream.getVideoTracks()[0];

                const capabilities = videoTrack.getCapabilities();
                if (capabilities.zoom) {
                    zoomCapabilities = capabilities.zoom;
                    zoomSlider.min = zoomCapabilities.min;
                    zoomSlider.max = zoomCapabilities.max;
                    zoomSlider.step = zoomCapabilities.step;
                    currentZoom = zoomCapabilities.min;
                    zoomSlider.value = currentZoom;
                    zoomInBtn.disabled = false;
                    zoomOutBtn.disabled = false;
                    zoomSlider.disabled = false;
                    updateZoomDisplay();
                    updateMessageBox('Camera ready. Zoom controls available.', 'info');
                    console.log('Zoom capabilities:', zoomCapabilities);
                } else {
                    updateMessageBox('Zoom is not supported by your camera or browser.', 'warning');
                    zoomInBtn.disabled = true;
                    zoomOutBtn.disabled = true;
                    zoomSlider.disabled = true;
                    console.log('Zoom not supported by device/browser.');
                }
                updateHandOutline();
                checkCaptureButtonState();

                cameraFeed.onloadedmetadata = () => {
                    startDetectionLoop();
                };

            } catch (error) {
                console.error('Error accessing camera:', error);
                if (error.name === 'NotAllowedError') {
                    updateMessageBox('Camera access denied. Please allow camera access in your browser settings.', 'error');
                } else if (error.name === 'NotFoundError') {
                    updateMessageBox('No camera found on your device.', 'error');
                } else if (error.name === 'OverconstrainedError') {
                    updateMessageBox('Requested camera not available. Trying default camera.', 'warning');
                    // Fallback to default if specific facingMode fails
                    currentFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user'; // Try the other one
                    initCamera(); // Recursively call with fallback
                }
                else {
                    updateMessageBox(`Error: ${error.message}. Could not access camera.`, 'error');
                }
                zoomInBtn.disabled = true;
                zoomOutBtn.disabled = true;
                zoomSlider.disabled = true;
                captureBtn.disabled = true;
            }
        }

        /**
         * Stops the camera feed and cancels the animation loop.
         */
        function stopCamera() {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                cameraFeed.srcObject = null;
                mediaStream = null;
                videoTrack = null;
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        /**
         * Applies the new zoom level to the video track.
         * @param {number} newZoom - The desired zoom level.
         */
        function applyZoom(newZoom) {
            if (!videoTrack || !zoomCapabilities) {
                updateMessageBox('Camera not ready or zoom not supported.', 'warning');
                return;
            }

            newZoom = Math.max(zoomCapabilities.min, Math.min(newZoom, zoomCapabilities.max));
            console.log('Attempting to apply zoom:', newZoom);

            videoTrack.applyConstraints({
                advanced: [{ zoom: newZoom }]
            }).then(() => {
                currentZoom = newZoom;
                zoomSlider.value = currentZoom;
                updateZoomDisplay();
                console.log('Zoom applied successfully to:', currentZoom);
            }).catch(error => {
                console.error('Error applying zoom:', error);
                updateMessageBox(`Failed to apply zoom: ${error.message}`, 'error');
            });
        }

        /**
         * Updates the zoom slider and potentially a text display (if added).
         */
        function updateZoomDisplay() {
            // This function is currently a placeholder.
            // You could add a text element here to show the current zoom value if desired.
        }

        /**
         * Updates the hand outline color based on the isHandDetected state.
         */
        function updateHandOutline() {
            if (isHandDetected) {
                handOutlineOverlay.classList.remove('red-outline');
                handOutlineOverlay.classList.add('green-outline');
            } else {
                handOutlineOverlay.classList.remove('green-outline');
                handOutlineOverlay.classList.add('red-outline');
            }
        }

        /**
         * Analyzes the lighting condition from the provided ImageData.
         * @param {ImageData} imageData - The image data from the canvas.
         * @returns {string} 'good', 'low', or 'high'.
         */
        function analyzeLighting(imageData) {
            const data = imageData.data;
            let totalBrightness = 0;
            const pixelCount = data.length / 4;

            if (pixelCount === 0) return 'unknown';

            for (let i = 0; i < data.length; i += 4) {
                totalBrightness += (data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114);
            }
            const averageBrightness = totalBrightness / pixelCount;

            if (averageBrightness < LOW_BRIGHTNESS_THRESHOLD) {
                return 'low';
            } else if (averageBrightness > HIGH_BRIGHTNESS_THRESHOLD) {
                return 'high';
            } else {
                return 'good';
            }
        }

        /**
         * Updates the combined status message in the message box.
         */
        function updateCombinedStatusMessage() {
            let handStatus = isHandDetected ? 'Hand detected!' : 'No hand visible.';
            let lightingStatusText = '';
            let messageType = 'info';

            switch (lightingCondition) {
                case 'low':
                    lightingStatusText = 'Lighting is too low. Move to a brighter area.';
                    messageType = 'warning';
                    break;
                case 'high':
                    lightingStatusText = 'Lighting is too bright. Avoid glare.';
                    messageType = 'warning';
                    break;
                case 'good':
                    lightingStatusText = 'Lighting looks good for details.';
                    messageType = 'success';
                    break;
                default:
                    lightingStatusText = 'Analyzing lighting...';
                    messageType = 'info';
            }

            const fullMessage = `${handStatus} ${lightingStatusText}`;
            updateMessageBox(fullMessage, messageType);
        }

        /**
         * Enables or disables the capture button based on hand detection and lighting.
         */
        function checkCaptureButtonState() {
            if (isHandDetected && lightingCondition === 'good') {
                captureBtn.disabled = false;
            } else {
                captureBtn.disabled = true;
            }
        }

        /**
         * Loads the Handpose model.
         */
        async function loadHandposeModel() {
            updateMessageBox('Loading hand detection model...', 'info');
            try {
                handposeModel = await handpose.load();
                updateMessageBox('Hand detection model loaded successfully!', 'info');
            } catch (error) {
                console.error('Error loading handpose model:', error);
                updateMessageBox('Failed to load hand detection model. Hand detection will not work.', 'error');
            }
        }

        /**
         * Starts the continuous hand and lighting detection loop.
         */
        async function startDetectionLoop() {
            if (!handposeModel || !cameraFeed.videoWidth || !cameraFeed.videoHeight || !mediaStream) {
                animationFrameId = requestAnimationFrame(startDetectionLoop); // Keep trying until camera is ready
                return;
            }

            // Draw the video frame onto the hidden canvas
            ctx.drawImage(cameraFeed, 0, 0, hiddenCanvas.width, hiddenCanvas.height);

            // Get image data for lighting analysis
            const imageData = ctx.getImageData(0, 0, hiddenCanvas.width, hiddenCanvas.height);
            lightingCondition = analyzeLighting(imageData);

            // Perform hand detection
            const predictions = await handposeModel.estimateHands(hiddenCanvas);

            // Determine if a hand is detected
            isHandDetected = predictions.length > 0;

            // Update UI based on detection and lighting
            updateHandOutline();
            updateCombinedStatusMessage();
            checkCaptureButtonState(); // Check button state in every frame

            animationFrameId = requestAnimationFrame(startDetectionLoop);
        }

        /**
         * Captures the current frame from the camera feed and displays it in the target palm box.
         */
        function captureImage() {
            if (!cameraFeed.srcObject) {
                updateMessageBox('Camera not active. Cannot capture image.', 'error');
                return;
            }
            if (captureBtn.disabled) {
                updateMessageBox('Cannot capture: Hand not detected or lighting is poor.', 'warning');
                return;
            }

            // Get intrinsic video dimensions (native resolution from camera sensor)
            const videoNativeWidth = cameraFeed.videoWidth;
            const videoNativeHeight = cameraFeed.videoHeight;

            // Get the displayed dimensions of the video element (what the user visually sees)
            const displayWidth = cameraFeed.offsetWidth;
            const displayHeight = cameraFeed.offsetHeight;

            // Set hidden canvas dimensions to match the *displayed* video element's dimensions.
            // This is the target size and aspect ratio for the final captured image.
            hiddenCanvas.width = displayWidth;
            hiddenCanvas.height = displayHeight;

            // Clear the canvas before drawing
            ctx.clearRect(0, 0, hiddenCanvas.width, hiddenCanvas.height);

            // Create a temporary canvas to draw the raw video frame.
            const tempRawCanvas = document.createElement('canvas');
            const tempRawCtx = tempRawCanvas.getContext('2d');
            tempRawCanvas.width = videoNativeWidth;
            tempRawCanvas.height = videoNativeHeight;
            tempRawCtx.drawImage(cameraFeed, 0, 0, videoNativeWidth, videoNativeHeight);

            // Determine if the *source* image (from tempRawCanvas) needs to be rotated
            // to match the *display's* orientation before cropping.
            // This is the crucial part for mobile phones that report portrait native video but display landscape.
            const isRawVideoPortrait = videoNativeHeight > videoNativeWidth;
            const isDisplayLandscape = displayWidth > displayHeight;

            let sourceForCropping = tempRawCanvas; // Default source for cropping
            let sourceForCroppingWidth = videoNativeWidth;
            let sourceForCroppingHeight = videoNativeHeight;

            // If the raw video is portrait AND the display is landscape, we need to rotate the source.
            // This is the most common scenario for phones.
            if (isRawVideoPortrait && isDisplayLandscape) {
                const rotatedSourceCanvas = document.createElement('canvas');
                const rotatedSourceCtx = rotatedSourceCanvas.getContext('2d');

                rotatedSourceCanvas.width = videoNativeHeight; // Swap dimensions
                rotatedSourceCanvas.height = videoNativeWidth;

                rotatedSourceCtx.save();
                rotatedSourceCtx.translate(rotatedSourceCanvas.width / 2, rotatedSourceCanvas.height / 2);
                rotatedSourceCtx.rotate(90 * Math.PI / 180); // Rotate 90 degrees clockwise
                rotatedSourceCtx.drawImage(tempRawCanvas, -videoNativeWidth / 2, -videoNativeHeight / 2, videoNativeWidth, videoNativeHeight);
                rotatedSourceCtx.restore();

                sourceForCropping = rotatedSourceCanvas; // Use the rotated canvas as the source for cropping
                sourceForCroppingWidth = rotatedSourceCanvas.width;
                sourceForCroppingHeight = rotatedSourceCanvas.height;
            }
            // Note: If the video is landscape and display is portrait, the existing object-fit: cover logic
            // should handle the cropping correctly without explicit rotation here, as the target canvas
            // will be portrait.

            // --- Calculate cropping parameters to mimic object-fit: cover ---
            // Use the dimensions of the (potentially rotated) sourceForCropping and the final hiddenCanvas dimensions.
            const sourceAspectRatio = sourceForCroppingWidth / sourceForCroppingHeight;
            const targetAspectRatio = displayWidth / displayHeight; // Aspect ratio of our final output canvas

            let sx = 0, sy = 0; // Source X, Y on sourceForCropping canvas
            let sCropWidth = sourceForCroppingWidth; // Source Width for cropping
            let sCropHeight = sourceForCroppingHeight; // Source Height for cropping

            if (sourceAspectRatio > targetAspectRatio) {
                // Source is wider than target display aspect ratio, crop horizontally
                sCropHeight = sourceForCroppingHeight;
                sCropWidth = sCropHeight * targetAspectRatio;
                sx = (sourceForCroppingWidth - sCropWidth) / 2;
                sy = 0;
            } else {
                // Source is taller than or same aspect ratio as target, crop vertically
                sCropWidth = sourceForCroppingWidth;
                sCropHeight = sCropWidth / targetAspectRatio;
                sy = (sourceForCroppingHeight - sCropHeight) / 2; // Fixed typo here: was `sHeight`
                sx = 0;
            }

            // --- Draw the cropped and oriented image to the final hiddenCanvas, applying mirroring ---
            ctx.save();
            // Apply mirroring ONLY if facingMode is 'user' (front camera)
            if (currentFacingMode === 'user') {
                ctx.translate(hiddenCanvas.width, 0); // Move origin to top-right for mirroring
                ctx.scale(-1, 1); // Apply mirroring for selfie view
            }

            // Draw the calculated cropped portion from sourceForCropping onto the hiddenCanvas,
            // filling the entire hiddenCanvas area.
            ctx.drawImage(sourceForCropping, sx, sy, sCropWidth, sCropHeight, 0, 0, hiddenCanvas.width, hiddenCanvas.height);
            ctx.restore(); // Restore the context after mirroring transform

            // Get the image data as a PNG data URL
            const imageDataUrl = hiddenCanvas.toDataURL('image/png');

            let targetInput, targetPreview, targetText, targetRemoveBtn;

            if (currentPalmTarget === 'left') {
                targetInput = leftPalmInput;
                targetPreview = leftPalmPreview;
                targetText = leftPalmText;
                targetRemoveBtn = leftPalmRemoveBtn;
            } else if (currentPalmTarget === 'right') {
                targetInput = rightPalmInput;
                targetPreview = rightPalmPreview;
                targetText = rightPalmText;
                targetRemoveBtn = rightPalmRemoveBtn;
            }

            if (targetInput && targetPreview && targetText && targetRemoveBtn) {
                targetPreview.src = imageDataUrl;
                targetPreview.style.display = 'block';
                targetText.style.display = 'none';
                targetInput.value = imageDataUrl;
                targetRemoveBtn.classList.remove('hidden'); // Show remove button
            }

            updateMessageBox('Image captured successfully!', 'success');
            closeCameraModal(); // Close the modal after capture
        }

        /**
         * Removes a captured image from the display and clears the hidden input.
         * @param {string} palm - 'left' or 'right' to indicate which palm image to remove.
         */
        function removeImage(palm) {
            let targetInput, targetPreview, targetText, targetRemoveBtn;

            if (palm === 'left') {
                targetInput = leftPalmInput;
                targetPreview = leftPalmPreview;
                targetText = leftPalmText;
                targetRemoveBtn = leftPalmRemoveBtn;
            } else if (palm === 'right') {
                targetInput = rightPalmInput;
                targetPreview = rightPalmPreview;
                targetText = rightPalmText;
                targetRemoveBtn = rightPalmRemoveBtn;
            }

            if (targetInput && targetPreview && targetText && targetRemoveBtn) {
                targetInput.value = ''; // Clear the hidden input value
                targetPreview.src = ''; // Clear the image source
                targetPreview.style.display = 'none'; // Hide the image
                targetText.style.display = 'flex'; // Show the text again (flex for centering)
                targetRemoveBtn.classList.add('hidden'); // Hide the remove button
                updateMessageBox(`${palm === 'left' ? 'Left' : 'Right'} palm image removed.`, 'info');
            }
        }

        // --- Modal Control Functions ---

        /**
         * Opens the camera modal and initializes the camera.
         * @param {string} palm - 'left' or 'right' to indicate which palm is being captured.
         */
        async function openCameraModal(palm) {
            currentPalmTarget = palm;
            modalTitle.textContent = `Capture ${palm === 'left' ? 'Left' : 'Right'} Palm Photo`;
            cameraModal.classList.add('show');
            // Re-initialize camera with current facing mode when modal opens
            await initCamera();
        }

        /**
         * Closes the camera modal and stops the camera.
         */
        function closeCameraModal() {
            cameraModal.classList.remove('show');
            stopCamera(); // Stop camera when modal closes
            currentPalmTarget = null; // Clear target
            updateMessageBox('', 'info'); // Clear message box
        }

        // --- Event Listeners ---

        // Listen for clicks on the capture trigger buttons
        captureTriggerButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                const palm = event.target.dataset.palm;
                openCameraModal(palm);
            });
        });

        // Listen for clicks on the remove image buttons
        removeImageButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                const palm = event.target.dataset.palm;
                removeImage(palm);
            });
        });

        closeModalBtn.addEventListener('click', closeCameraModal);

        zoomInBtn.addEventListener('click', () => {
            if (zoomCapabilities) {
                let newZoom = currentZoom + (zoomCapabilities.step || (zoomCapabilities.max - zoomCapabilities.min) / 10);
                applyZoom(newZoom);
            }
        });

        zoomOutBtn.addEventListener('click', () => {
            if (zoomCapabilities) {
                let newZoom = currentZoom - (zoomCapabilities.step || (zoomCapabilities.max - zoomCapabilities.min) / 10);
                applyZoom(newZoom);
            }
        });

        zoomSlider.addEventListener('input', (event) => {
            if (zoomCapabilities) {
                const newZoom = parseFloat(event.target.value);
                applyZoom(newZoom);
            }
        });

        captureBtn.addEventListener('click', captureImage);

        // New: Toggle Camera button functionality
        toggleCameraBtn.addEventListener('click', () => {
            currentFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user';
            initCamera(); // Re-initialize camera with the new facing mode
        });


        // --- Initial Load ---
        window.onload = async () => {
            await loadHandposeModel(); // Load the ML model once when the page loads
            // Camera will be initialized when the modal is opened
        };

        // Cleanup: Stop camera stream if the page is closed (as a fallback, modal close handles it too)
        window.addEventListener('beforeunload', () => {
            stopCamera();
        });
    </script>
</body>
</html>
