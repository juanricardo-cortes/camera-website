<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Palm Photo Capture with Custom Camera</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- TensorFlow.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <!-- MediaPipe Hands CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js"></script>
    <!-- HandPose model from TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose@0.0.7/dist/handpose.min.js"></script>

    <style>
        /* Custom styles for better visual appeal */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px; /* Add some padding for smaller screens */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }

        /* User's original palm upload container styles */
        .palm-upload-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }
        /* New container for each palm box and its buttons */
        .palm-input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px; /* Space between box and buttons */
        }

        .upload-box {
            border: 2px dashed #d7bfb9;
            border-radius: 8px;
            width: 180px;
            height: 180px; /* Increased height to accommodate image */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            background-color: #fffaf8;
            font-family: sans-serif;
            font-size: 14px;
            color: #7a3e2f;
            text-align: center;
            position: relative; /* For positioning captured image */
            overflow: hidden; /* Hide overflow for rounded corners */
            padding: 10px; /* Add padding inside the box */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }
        .upload-box .placeholder-text {
            display: flex; /* Ensure flex for centering */
            align-items: center;
            justify-content: center;
            height: 100%; /* Occupy full height when no images */
            width: 100%;
            padding: 0 5px;
            box-sizing: border-box;
        }
        .upload-box .photo-gallery {
            display: flex;
            flex-wrap: wrap;
            gap: 5px; /* Small gap between images */
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%; /* Fill the upload-box */
            overflow-y: auto; /* Allow scrolling if many photos */
            padding: 5px; /* Padding inside gallery */
            box-sizing: border-box;
        }
        .photo-card {
            position: relative;
            width: 70px; /* Thumbnail size */
            height: 70px;
            border: 1px solid #ccc;
            border-radius: 4px;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0; /* Prevent cards from shrinking */
        }
        .photo-card img {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Cover the thumbnail area */
            border-radius: 4px;
        }
        .photo-card .delete-photo-btn {
            position: absolute;
            top: 2px;
            right: 2px;
            background-color: rgba(239, 68, 68, 0.8); /* Red with transparency */
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            line-height: 1;
            padding: 0;
            opacity: 0.8;
            transition: opacity 0.2s;
            z-index: 10; /* Ensure button is above image */
        }
        .photo-card .delete-photo-btn:hover {
            opacity: 1;
        }

        /* Styles for the buttons now they are outside the box */
        button.capture-trigger-btn,
        button.remove-image-btn {
            background-color: #4f46e5;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.06);
            border: none;
            flex-shrink: 0;
            width: 100%; /* Make buttons full width of the group */
            max-width: 180px; /* Match upload-box width */
        }
        button.capture-trigger-btn:hover,
        button.remove-image-btn:hover {
            background-color: #4338ca;
            transform: translateY(-1px);
        }
        button.remove-image-btn {
            background-color: #ef4444; /* Red color for remove button */
        }
        button.remove-image-btn:hover {
            background-color: #dc2626;
        }

        /* Modal specific styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .modal.show {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.08);
            max-width: 95vw; /* Responsive width for modal */
            width: 500px; /* Max width for desktop */
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .modal-header {
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e5e7eb;
        }
        .modal-header h2 {
            font-size: 1.25rem;
            font-weight: 700;
            color: #374151;
        }
        .modal-close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6b7280;
            transition: color 0.2s;
        }
        .modal-close-btn:hover {
            color: #1f2937;
        }

        /* Camera app specific styles (from previous version, adapted for modal) */
        .camera-area {
            position: relative;
            width: 100%;
            /* Default to landscape 4:3 aspect ratio for desktop */
            padding-top: 75%; /* (height / width) * 100% = (3/4) * 100% */
            overflow: hidden;
            background-color: #000;
        }

        /* Adjust for mobile portrait (e.g., up to 768px width) */
        @media (max-width: 768px) {
            .camera-area {
                /* For portrait, use a 3:4 aspect ratio (height > width) */
                padding-top: 133.33%; /* (4/3) * 100% */
            }
        }

        video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            /* transform: scaleX(-1); This will be set dynamically by JS */
        }
        #hiddenCanvas {
            display: none;
        }
        .hand-outline-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%; /* Changed from 60% to 90% */
            height: 90%; /* Changed from 60% to 90% */
            border: 4px solid;
            border-radius: 1rem;
            pointer-events: none;
            transition: border-color 0.3s ease-in-out;
            overflow: hidden; /* Crucial to contain the scanning line */
        }
        .red-outline {
            border-color: #ef4444;
        }
        .green-outline {
            border-color: #22c55e;
        }
        /* Scanning line effect */
        .hand-outline-overlay::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%; /* Start off-screen to the left */
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(34, 197, 94, 0.3), transparent); /* Green gradient */
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        .hand-outline-overlay.scanning::after {
            opacity: 1;
            animation: scan-line 2s infinite linear; /* Animate the scan line */
        }

        @keyframes scan-line {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .controls {
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .button-group {
            display: flex;
            justify-content: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        /* New class to control visibility of zoom options */
        .zoom-controls-group {
            display: flex; /* Default to flex */
            justify-content: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        /* Hide zoom controls if not supported */
        .zoom-controls-group.hidden-zoom {
            display: none;
        }

        button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: none;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.06), 0 1px 2px -1px rgba(0, 0, 0, 0.04);
        }
        .btn-primary {
            background-color: #4f46e5;
            color: white;
        }
        .btn-primary:hover {
            background-color: #4338ca;
        }
        .btn-secondary {
            background-color: #e5e7eb;
            color: #374151;
        }
        .btn-secondary:hover {
            background-color: #d1d5db;
        }
        .btn-capture {
            background-color: #10b981;
            color: white;
        }
        .btn-capture:hover {
            background-color: #059669;
        }
        .btn-toggle-auto-capture {
            background-color: #6366f1; /* Indigo for toggle */
            color: white;
        }
        .btn-toggle-auto-capture.active {
            background-color: #10b981; /* Green when active */
        }
        .btn-toggle-auto-capture:hover {
            background-color: #4f46e5;
        }
        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 8px;
            background: #e0e7ff;
            border-radius: 5px;
            outline: none;
            transition: opacity .2s;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4f46e5;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4f46e5;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        /* Style for the zoom slider label */
        .zoom-slider-label {
            display: block; /* Ensure it takes its own line */
            text-align: center;
            color: #374151;
            font-weight: 500;
        }
        /* Hide the zoom slider label if zoom is not supported */
        .zoom-slider-label.hidden-zoom {
            display: none;
        }

        #message-box {
            padding: 0.75rem;
            border-radius: 0.5rem;
            text-align: center;
            font-size: 0.875rem;
            display: none;
            margin-bottom: 0.5rem;
        }
        .message-info {
            background-color: #e0e7ff;
            color: #4f46e5;
        }
        .message-warning {
            background-color: #fffbeb;
            color: #f59e0b;
        }
        .message-error {
            background-color: #fef2f2;
            color: #ef4444;
        }
        .message-success {
            background-color: #ecfdf5;
            color: #10b981;
        }
    </style>
</head>
<body>

    <div class="palm-upload-container">
        <div class="palm-input-group">
            <div class="upload-box" id="leftPalmBox">
                <input type="hidden" id="leftPalmInput" name="leftPalmPhoto" />
                <span id="leftPalmText" class="placeholder-text">Left Palm Photo *</span>
                <div class="photo-gallery" id="leftPalmGallery">
                    <!-- Captured images will be appended here -->
                </div>
            </div>
            <button class="capture-trigger-btn" data-palm="left">Capture Left Palm</button>
        </div>

        <div class="palm-input-group">
            <div class="upload-box" id="rightPalmBox">
                <input type="hidden" id="rightPalmInput" name="rightPalmPhoto" />
                <span id="rightPalmText" class="placeholder-text">Right Palm Photo *</span>
                <div class="photo-gallery" id="rightPalmGallery">
                    <!-- Captured images will be appended here -->
                </div>
            </div>
            <button class="capture-trigger-btn" data-palm="right">Capture Right Palm</button>
        </div>
    </div>

    <!-- The Modal for Camera Application -->
    <div id="cameraModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Capture Palm Photo</h2>
                <button class="modal-close-btn" id="closeModalBtn">&times;</button>
            </div>
            <div class="camera-area">
                <video id="cameraFeed" autoplay playsinline></video>
                <canvas id="hiddenCanvas"></canvas>
                <div id="handOutlineOverlay" class="hand-outline-overlay red-outline"></div>
            </div>
            <div class="controls">
                <div id="message-box" class="message-info"></div>
                <div class="button-group">
                    <button id="captureBtn" class="btn-capture" disabled>Capture Image</button>
                    <button id="toggleCameraBtn" class="btn-secondary">Toggle Camera</button>
                    <button id="toggleAutoCaptureBtn" class="btn-toggle-auto-capture">Toggle Auto Capture</button>
                </div>
                <!-- Zoom controls group -->
                <div id="zoomControlsGroup" class="zoom-controls-group">
                    <button id="zoomOutBtn" class="btn-secondary">Zoom Out</button>
                    <button id="zoomInBtn" class="btn-primary">Zoom In</button>
                </div>
                <label for="zoomSlider" id="zoomSliderLabel" class="zoom-slider-label">Zoom Level:</label>
                <input type="range" id="zoomSlider" min="0" max="100" value="0" class="w-full" disabled>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const cameraModal = document.getElementById('cameraModal');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const modalTitle = document.getElementById('modalTitle');
        const captureTriggerButtons = document.querySelectorAll('.palm-input-group .capture-trigger-btn');

        const cameraFeed = document.getElementById('cameraFeed');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomSliderLabel = document.getElementById('zoomSliderLabel');
        const zoomControlsGroup = document.getElementById('zoomControlsGroup');

        const messageBox = document.getElementById('message-box');
        const handOutlineOverlay = document.getElementById('handOutlineOverlay');
        const hiddenCanvas = document.getElementById('hiddenCanvas');
        const ctx = hiddenCanvas.getContext('2d');
        const captureBtn = document.getElementById('captureBtn');
        const toggleCameraBtn = document.getElementById('toggleCameraBtn');
        const toggleAutoCaptureBtn = document.getElementById('toggleAutoCaptureBtn');

        // References for left palm elements
        const leftPalmInput = document.getElementById('leftPalmInput');
        const leftPalmText = document.getElementById('leftPalmText');
        const leftPalmGallery = document.getElementById('leftPalmGallery');

        // References for right palm elements
        const rightPalmInput = document.getElementById('rightPalmInput');
        const rightPalmText = document.getElementById('rightPalmText');
        const rightPalmGallery = document.getElementById('rightPalmGallery');

        // --- State Variables ---
        let mediaStream = null;
        let videoTrack = null;
        let zoomCapabilities = null;
        let currentZoom = 0;
        let isHandDetected = false;
        let lightingCondition = 'unknown'; // 'good', 'low', 'high', 'poor_contrast'
        let handposeModel = null;
        let currentPalmTarget = null;
        let animationFrameId = null;
        let currentFacingMode = 'user'; // 'user' for front camera, 'environment' for back camera

        let isAutoCaptureActive = false;
        const autoCaptureCooldown = 3000; // 3 seconds cooldown between auto-captures
        let lastAutoCaptureTime = 0;
        let scanCompletionTimeoutId = null; // New: Timeout ID for simulated scan
        const scanDuration = 1500; // New: Duration of simulated scan before auto-capture (1.5 seconds)

        // Arrays to store captured image data URLs for each palm
        let leftPalmPhotos = [];
        let rightPalmPhotos = [];

        // Lighting thresholds (adjust as needed for your environment)
        const LOW_BRIGHTNESS_THRESHOLD = 60;
        const HIGH_BRIGHTNESS_THRESHOLD = 180;
        const MIN_CONTRAST_THRESHOLD = 30; // Minimum standard deviation of luminance for good contrast

        // --- Utility Functions ---

        /**
         * Displays a message in the message box.
         * @param {string} message - The message to display.
         * @param {string} type - The type of message ('info', 'warning', 'error', 'success').
         */
        function updateMessageBox(message, type = 'info') {
            messageBox.textContent = message;
            messageBox.style.display = 'block';
            messageBox.className = `message-box message-${type}`;
        }

        /**
         * Initializes the camera feed and sets up zoom controls.
         */
        async function initCamera() {
            try {
                // Stop any existing camera stream first
                stopCamera();

                // Set video constraints based on current facing mode
                const videoConstraints = {
                    facingMode: currentFacingMode
                };

                mediaStream = await navigator.mediaDevices.getUserMedia({ video: videoConstraints });
                cameraFeed.srcObject = mediaStream;

                // Apply mirroring for front camera, remove for back camera
                cameraFeed.style.transform = (currentFacingMode === 'user') ? 'scaleX(-1)' : 'none';

                videoTrack = mediaStream.getVideoTracks()[0];

                const capabilities = videoTrack.getCapabilities();
                if (capabilities.zoom) {
                    zoomCapabilities = capabilities.zoom;
                    zoomSlider.min = zoomCapabilities.min;
                    zoomSlider.max = zoomCapabilities.max;
                    zoomSlider.step = zoomCapabilities.step;
                    currentZoom = zoomCapabilities.min;
                    zoomSlider.value = currentZoom;
                    // Ensure zoom controls are visible
                    zoomControlsGroup.classList.remove('hidden-zoom');
                    zoomSliderLabel.classList.remove('hidden-zoom');
                    zoomSlider.classList.remove('hidden-zoom'); // Make sure the slider itself is visible
                    zoomInBtn.disabled = false;
                    zoomOutBtn.disabled = false;
                    zoomSlider.disabled = false;
                    updateZoomDisplay();
                    updateMessageBox('Camera ready. Zoom controls available.', 'info');
                    console.log('Zoom capabilities:', zoomCapabilities);
                } else {
                    updateMessageBox('Zoom is not supported by your camera or browser.', 'warning');
                    // Hide zoom controls
                    zoomControlsGroup.classList.add('hidden-zoom');
                    zoomSliderLabel.classList.add('hidden-zoom');
                    zoomSlider.classList.add('hidden-zoom'); // Hide the slider itself
                    zoomInBtn.disabled = true;
                    zoomOutBtn.disabled = true;
                    zoomSlider.disabled = true;
                    console.log('Zoom not supported by device/browser.');
                }
                updateHandOutline();
                checkCaptureButtonState();

                cameraFeed.onloadedmetadata = () => {
                    startDetectionLoop();
                };

            }
            catch (error) {
                console.error('Error accessing camera:', error);
                if (error.name === 'NotAllowedError') {
                    updateMessageBox('Camera access denied. Please allow camera access in your browser settings.', 'error');
                } else if (error.name === 'NotFoundError') {
                    updateMessageBox('No camera found on your device.', 'error');
                } else if (error.name === 'OverconstrainedError') {
                    updateMessageBox('Requested camera not available. Trying default camera.', 'warning');
                    // Fallback to default if specific facingMode fails
                    currentFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user'; // Try the other one
                    initCamera(); // Recursively call with fallback
                }
                else {
                    updateMessageBox(`Error: ${error.message}. Could not access camera.`, 'error');
                }
                // Always hide zoom controls if camera init fails
                zoomControlsGroup.classList.add('hidden-zoom');
                zoomSliderLabel.classList.add('hidden-zoom');
                zoomSlider.classList.add('hidden-zoom'); // Hide the slider itself
                zoomInBtn.disabled = true;
                zoomOutBtn.disabled = true;
                zoomSlider.disabled = true;
                captureBtn.disabled = true;
            }
        }

        /**
         * Stops the camera feed and cancels the animation loop.
         */
        function stopCamera() {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                cameraFeed.srcObject = null;
                mediaStream = null;
                videoTrack = null;
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            // Clear any pending auto-capture timeout
            if (scanCompletionTimeoutId) {
                clearTimeout(scanCompletionTimeoutId);
                scanCompletionTimeoutId = null;
            }
        }

        /**
         * Applies the new zoom level to the video track.
         * @param {number} newZoom - The desired zoom level.
         */
        function applyZoom(newZoom) {
            if (!videoTrack || !zoomCapabilities) {
                updateMessageBox('Camera not ready or zoom not supported.', 'warning');
                return;
            }

            newZoom = Math.max(zoomCapabilities.min, Math.min(newZoom, zoomCapabilities.max));
            console.log('Attempting to apply zoom:', newZoom);

            videoTrack.applyConstraints({
                advanced: [{ zoom: newZoom }]
            }).then(() => {
                currentZoom = newZoom;
                zoomSlider.value = currentZoom;
                updateZoomDisplay();
                console.log('Zoom applied successfully to:', currentZoom);
            }).catch(error => {
                console.error('Error applying zoom:', error);
                updateMessageBox(`Failed to apply zoom: ${error.message}`, 'error');
            });
        }

        /**
         * Updates the zoom slider and potentially a text display (if added).
         */
        function updateZoomDisplay() {
            // This function is currently a placeholder.
            // You could add a text element here to show the current zoom value if desired.
        }

        /**
         * Updates the hand outline color based on the isHandDetected state.
         */
        function updateHandOutline() {
            if (isHandDetected) {
                handOutlineOverlay.classList.remove('red-outline');
                handOutlineOverlay.classList.add('green-outline');
            } else {
                handOutlineOverlay.classList.remove('green-outline');
                handOutlineOverlay.classList.add('red-outline');
            }
            // Control scanning animation
            if (isHandDetected && lightingCondition === 'good') {
                handOutlineOverlay.classList.add('scanning');
            } else {
                handOutlineOverlay.classList.remove('scanning');
            }
        }

        /**
         * Analyzes the lighting condition from the provided ImageData, including contrast.
         * @param {ImageData} imageData - The image data from the canvas.
         * @returns {string} 'good', 'low', 'high', or 'poor_contrast'.
         */
        function analyzeLighting(imageData) {
            const data = imageData.data;
            let totalLuminance = 0;
            let luminances = [];
            const pixelCount = data.length / 4;

            if (pixelCount === 0) return 'unknown';

            for (let i = 0; i < data.length; i += 4) {
                // Calculate luminance (perceived brightness)
                const luminance = (data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114);
                totalLuminance += luminance;
                luminances.push(luminance);
            }
            const averageLuminance = totalLuminance / pixelCount;

            // Calculate standard deviation of luminance for contrast
            let variance = 0;
            for (let i = 0; i < luminances.length; i++) {
                variance += Math.pow(luminances[i] - averageLuminance, 2);
            }
            const luminanceStdDev = Math.sqrt(variance / luminances.length);

            if (averageLuminance < LOW_BRIGHTNESS_THRESHOLD) {
                return 'low';
            } else if (averageLuminance > HIGH_BRIGHTNESS_THRESHOLD) {
                return 'high';
            } else if (luminanceStdDev < MIN_CONTRAST_THRESHOLD) {
                return 'poor_contrast'; // New state for low contrast
            } else {
                return 'good';
            }
        }

        /**
         * Updates the combined status message in the message box.
         */
        function updateCombinedStatusMessage() {
            let handStatus = isHandDetected ? 'Hand detected!' : 'No hand visible.';
            let lightingStatusText = '';
            let messageType = 'info';

            switch (lightingCondition) {
                case 'low':
                    lightingStatusText = 'Lighting is too low. Move to a brighter area.';
                    messageType = 'warning';
                    break;
                case 'high':
                    lightingStatusText = 'Lighting is too bright. Avoid glare.';
                    messageType = 'warning';
                    break;
                case 'poor_contrast':
                    lightingStatusText = 'Poor contrast. Adjust lighting to see details (e.g., lines).';
                    messageType = 'warning';
                    break;
                case 'good':
                    lightingStatusText = 'Lighting looks good for details.';
                    messageType = 'success';
                    break;
                default:
                    lightingStatusText = 'Analyzing lighting...';
                    messageType = 'info';
            }

            const fullMessage = `${handStatus} ${lightingStatusText}`;
            updateMessageBox(fullMessage, messageType);
        }

        /**
         * Enables or disables the capture button based on hand detection and lighting.
         */
        function checkCaptureButtonState() {
            if (isHandDetected && lightingCondition === 'good') {
                captureBtn.disabled = false;
            } else {
                captureBtn.disabled = true;
            }
        }

        /**
         * Loads the Handpose model.
         */
        async function loadHandposeModel() {
            updateMessageBox('Loading hand detection model...', 'info');
            try {
                handposeModel = await handpose.load();
                updateMessageBox('Hand detection model loaded successfully!', 'info');
            } catch (error) {
                console.error('Error loading handpose model:', error);
                updateMessageBox('Failed to load hand detection model. Hand detection will not work.', 'error');
            }
        }

        /**
         * Starts the continuous hand and lighting detection loop.
         */
        async function startDetectionLoop() {
            if (!handposeModel || !cameraFeed.videoWidth || !cameraFeed.videoHeight || !mediaStream) {
                animationFrameId = requestAnimationFrame(startDetectionLoop); // Keep trying until camera is ready
                return;
            }

            // Draw the video frame onto the hidden canvas
            ctx.drawImage(cameraFeed, 0, 0, hiddenCanvas.width, hiddenCanvas.height);

            // Get image data for lighting analysis
            const imageData = ctx.getImageData(0, 0, hiddenCanvas.width, hiddenCanvas.height);
            lightingCondition = analyzeLighting(imageData);

            // Perform hand detection
            const predictions = await handposeModel.estimateHands(hiddenCanvas);

            // Determine if a hand is detected
            isHandDetected = predictions.length > 0;

            // Update UI based on detection and lighting
            updateHandOutline();
            updateCombinedStatusMessage();
            checkCaptureButtonState(); // Check button state in every frame

            // --- Auto-capture logic with simulated scan delay ---
            if (isAutoCaptureActive) {
                const now = Date.now();
                const canCaptureNow = (now - lastAutoCaptureTime > autoCaptureCooldown);

                if (isHandDetected && lightingCondition === 'good') {
                    if (!scanCompletionTimeoutId && canCaptureNow) {
                        // Start simulated scan if not already scanning and cooldown allows
                        updateMessageBox('Scanning... Hold hand steady.', 'info');
                        scanCompletionTimeoutId = setTimeout(() => {
                            // After scanDuration, check conditions again before capturing
                            if (isHandDetected && lightingCondition === 'good') {
                                captureImage();
                                lastAutoCaptureTime = Date.now(); // Update last capture time
                            } else {
                                updateMessageBox('Scan interrupted. Conditions changed.', 'warning');
                            }
                            scanCompletionTimeoutId = null; // Reset timeout ID
                        }, scanDuration);
                    }
                } else {
                    // Conditions not met, cancel any pending scan
                    if (scanCompletionTimeoutId) {
                        clearTimeout(scanCompletionTimeoutId);
                        scanCompletionTimeoutId = null;
                        updateMessageBox('Scan cancelled. Adjust hand or lighting.', 'warning');
                    }
                }
            } else {
                // Auto-capture is off, ensure any pending scan is cleared
                if (scanCompletionTimeoutId) {
                    clearTimeout(scanCompletionTimeoutId);
                    scanCompletionTimeoutId = null;
                }
            }


            animationFrameId = requestAnimationFrame(startDetectionLoop);
        }

        /**
         * Applies a simple contrast/sharpening filter to the canvas context.
         * This is a basic post-processing step to make lines "pop".
         * @param {CanvasRenderingContext2D} context - The 2D context of the canvas.
         * @param {number} amount - The intensity of the filter (e.g., 1.2 for 20% increase).
         */
        function applyContrastFilter(context, amount) {
            const imageData = context.getImageData(0, 0, context.canvas.width, context.canvas.height);
            const pixels = imageData.data;
            const factor = (259 * (amount + 255)) / (255 * (259 - amount));

            for (let i = 0; i < pixels.length; i += 4) {
                pixels[i] = factor * (pixels[i] - 128) + 128;     // Red
                pixels[i + 1] = factor * (pixels[i + 1] - 128) + 128; // Green
                pixels[i + 2] = factor * (pixels[i + 2] - 128) + 128; // Blue
            }
            context.putImageData(imageData, 0, 0);
        }


        /**
         * Captures the current frame from the camera feed and displays it in the target palm box.
         */
        function captureImage() {
            if (!cameraFeed.srcObject) {
                updateMessageBox('Camera not active. Cannot capture image.', 'error');
                return;
            }
            // If auto-capture is active, we bypass the manual button's disabled state.
            // If manual capture, ensure button is enabled.
            if (!isAutoCaptureActive && captureBtn.disabled) {
                updateMessageBox('Cannot capture: Hand not detected or lighting is poor.', 'warning');
                return;
            }

            // Get intrinsic video dimensions (native resolution from camera sensor)
            const videoNativeWidth = cameraFeed.videoWidth;
            const videoNativeHeight = cameraFeed.videoHeight;

            // Get the displayed dimensions of the video element (what the user visually sees)
            const displayWidth = cameraFeed.offsetWidth;
            const displayHeight = cameraFeed.offsetHeight;

            // Set hidden canvas dimensions to match the *displayed* video element's dimensions.
            // This is the target size and aspect ratio for the final captured image.
            hiddenCanvas.width = displayWidth;
            hiddenCanvas.height = displayHeight;

            // Clear the canvas before drawing
            ctx.clearRect(0, 0, hiddenCanvas.width, hiddenCanvas.height);

            // Create a temporary canvas to draw the raw video frame.
            const tempRawCanvas = document.createElement('canvas');
            const tempRawCtx = tempRawCanvas.getContext('2d');
            tempRawCanvas.width = videoNativeWidth;
            tempRawCanvas.height = videoNativeHeight;
            tempRawCtx.drawImage(cameraFeed, 0, 0, videoNativeWidth, videoNativeHeight);

            // Determine if the *source* image (from tempRawCanvas) needs to be rotated
            // to match the *display's* orientation before cropping.
            // This is the crucial part for mobile phones that report portrait native video but display landscape.
            const isRawVideoPortrait = videoNativeHeight > videoNativeWidth;
            const isDisplayLandscape = displayWidth > displayHeight;

            let sourceForCropping = tempRawCanvas; // Default source for cropping
            let sourceForCroppingWidth = videoNativeWidth;
            let sourceForCroppingHeight = videoNativeHeight;

            // If the raw video is portrait AND the display is landscape, we need to rotate the source.
            // This is the most common scenario for phones.
            if (isRawVideoPortrait && isDisplayLandscape) {
                const rotatedSourceCanvas = document.createElement('canvas');
                const rotatedSourceCtx = rotatedSourceCanvas.getContext('2d');

                rotatedSourceCanvas.width = videoNativeHeight; // Swap dimensions
                rotatedSourceCanvas.height = videoNativeWidth;

                rotatedSourceCtx.save();
                rotatedSourceCtx.translate(rotatedSourceCanvas.width / 2, rotatedSourceCanvas.height / 2);
                rotatedSourceCtx.rotate(90 * Math.PI / 180); // Rotate 90 degrees clockwise
                rotatedSourceCtx.drawImage(tempRawCanvas, -videoNativeWidth / 2, -videoNativeHeight / 2, videoNativeWidth, videoNativeHeight);
                rotatedSourceCtx.restore();

                sourceForCropping = rotatedSourceCanvas; // Use the rotated canvas as the source for cropping
                sourceForCroppingWidth = rotatedSourceCanvas.width;
                sourceForCroppingHeight = rotatedSourceCanvas.height;
            }
            // Note: If the video is landscape and display is portrait, the existing object-fit: cover logic
            // should handle the cropping correctly without explicit rotation here, as the target canvas
            // will be portrait.

            // --- Calculate cropping parameters to mimic object-fit: cover ---
            // Use the dimensions of the (potentially rotated) sourceForCropping and the final hiddenCanvas dimensions.
            const sourceAspectRatio = sourceForCroppingWidth / sourceForCroppingHeight;
            const targetAspectRatio = displayWidth / displayHeight; // Aspect ratio of our final output canvas

            let sx = 0, sy = 0; // Source X, Y on sourceForCropping canvas
            let sCropWidth = sourceForCroppingWidth; // Source Width for cropping
            let sCropHeight = sourceForCroppingHeight; // Source Height for cropping

            if (sourceAspectRatio > targetAspectRatio) {
                // Source is wider than target display aspect ratio, crop horizontally
                sCropHeight = sourceForCroppingHeight;
                sCropWidth = sCropHeight * targetAspectRatio;
                sx = (sourceForCroppingWidth - sCropWidth) / 2;
                sy = 0;
            } else {
                // Source is taller than or same aspect ratio as target, crop vertically
                sCropWidth = sourceForCroppingWidth;
                sCropHeight = sCropWidth / targetAspectRatio;
                sy = (sourceForCroppingHeight - sCropHeight) / 2;
                sx = 0;
            }

            // --- Draw the cropped and oriented image to the final hiddenCanvas, applying mirroring ---
            ctx.save();
            // Apply mirroring ONLY if facingMode is 'user' (front camera)
            if (currentFacingMode === 'user') {
                ctx.translate(hiddenCanvas.width, 0); // Move origin to top-right for mirroring
                ctx.scale(-1, 1); // Apply mirroring for selfie view
            }

            // Draw the calculated cropped portion from sourceForCropping onto the hiddenCanvas,
            // filling the entire hiddenCanvas area.
            ctx.drawImage(sourceForCropping, sx, sy, sCropWidth, sCropHeight, 0, 0, hiddenCanvas.width, hiddenCanvas.height);
            ctx.restore(); // Restore the context after mirroring transform

            // --- Apply post-capture visual enhancement (contrast/sharpening) ---
            // This is where lines and fingerprints will "light up" in the captured image.
            applyContrastFilter(ctx, 50); // Apply a contrast filter (adjust 50 for intensity)

            // Get the image data as a PNG data URL
            const imageDataUrl = hiddenCanvas.toDataURL('image/png');

            // Add the image to the appropriate palm's photo array
            if (currentPalmTarget === 'left') {
                leftPalmPhotos.push(imageDataUrl);
                renderPhotos('left');
            } else if (currentPalmTarget === 'right') {
                rightPalmPhotos.push(imageDataUrl);
                renderPhotos('right');
            }

            updateMessageBox('Image captured successfully!', 'success');
            closeCameraModal(); // Close the modal after capture
        }

        /**
         * Renders the photos for a given palm into its gallery.
         * @param {string} palm - 'left' or 'right'.
         */
        function renderPhotos(palm) {
            let galleryElement, photosArray, textElement, inputElement;

            if (palm === 'left') {
                galleryElement = leftPalmGallery;
                photosArray = leftPalmPhotos;
                textElement = leftPalmText;
                inputElement = leftPalmInput;
            } else if (palm === 'right') {
                galleryElement = rightPalmGallery;
                photosArray = rightPalmPhotos;
                textElement = rightPalmText;
                inputElement = rightPalmInput;
            }

            // Clear existing photos
            galleryElement.innerHTML = '';

            if (photosArray.length === 0) {
                textElement.style.display = 'flex'; // Show placeholder text
            } else {
                textElement.style.display = 'none'; // Hide placeholder text
                photosArray.forEach((dataUrl, index) => {
                    const photoCard = document.createElement('div');
                    photoCard.classList.add('photo-card');
                    photoCard.dataset.index = index; // Store index for deletion

                    const img = document.createElement('img');
                    img.src = dataUrl;
                    img.alt = `${palm} Palm Photo ${index + 1}`;

                    const deleteBtn = document.createElement('button');
                    deleteBtn.classList.add('delete-photo-btn');
                    deleteBtn.textContent = 'x';
                    deleteBtn.title = 'Remove photo';
                    deleteBtn.addEventListener('click', (event) => {
                        event.stopPropagation(); // Prevent click from bubbling up to upload-box
                        removePhoto(palm, index);
                    });

                    photoCard.appendChild(img);
                    photoCard.appendChild(deleteBtn);
                    galleryElement.appendChild(photoCard);
                });
            }
            // Update the hidden input with the JSON string of all photos
            inputElement.value = JSON.stringify(photosArray);
        }

        /**
         * Removes a specific photo from the gallery and updates the data.
         * @param {string} palm - 'left' or 'right'.
         * @param {number} index - The index of the photo to remove.
         */
        function removePhoto(palm, index) {
            let photosArray;
            if (palm === 'left') {
                photosArray = leftPalmPhotos;
            } else if (palm === 'right') {
                photosArray = rightPalmPhotos;
            }

            if (index > -1 && index < photosArray.length) {
                photosArray.splice(index, 1); // Remove photo from array
                renderPhotos(palm); // Re-render gallery
                updateMessageBox(`${palm === 'left' ? 'Left' : 'Right'} palm photo removed.`, 'info');
            }
        }

        // --- Modal Control Functions ---

        /**
         * Opens the camera modal and initializes the camera.
         * @param {string} palm - 'left' or 'right' to indicate which palm is being captured.
         */
        async function openCameraModal(palm) {
            currentPalmTarget = palm;
            modalTitle.textContent = `Capture ${palm === 'left' ? 'Left' : 'Right'} Palm Photo`;
            cameraModal.classList.add('show');
            // Re-initialize camera with current facing mode when modal opens
            await initCamera();
        }

        /**
         * Closes the camera modal and stops the camera.
         */
        function closeCameraModal() {
            cameraModal.classList.remove('show');
            stopCamera(); // Stop camera when modal closes
            currentPalmTarget = null; // Clear target
            updateMessageBox('', 'info'); // Clear message box
        }

        // --- Event Listeners ---

        // Listen for clicks on the capture trigger buttons
        captureTriggerButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                const palm = event.target.dataset.palm;
                openCameraModal(palm);
            });
        });

        closeModalBtn.addEventListener('click', closeCameraModal);

        zoomInBtn.addEventListener('click', () => {
            if (zoomCapabilities) {
                let newZoom = currentZoom + (zoomCapabilities.step || (zoomCapabilities.max - zoomCapabilities.min) / 10);
                applyZoom(newZoom);
            }
        });

        zoomOutBtn.addEventListener('click', () => {
            if (zoomCapabilities) {
                let newZoom = currentZoom - (zoomCapabilities.step || (zoomCapabilities.max - zoomCapabilities.min) / 10);
                applyZoom(newZoom);
            }
        });

        zoomSlider.addEventListener('input', (event) => {
            if (zoomCapabilities) {
                const newZoom = parseFloat(event.target.value);
                applyZoom(newZoom);
            }
        });

        captureBtn.addEventListener('click', captureImage);

        // New: Toggle Camera button functionality
        toggleCameraBtn.addEventListener('click', () => {
            currentFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user';
            initCamera(); // Re-initialize camera with the new facing mode
        });

        // New: Toggle Auto Capture button functionality
        toggleAutoCaptureBtn.addEventListener('click', () => {
            isAutoCaptureActive = !isAutoCaptureActive;
            if (isAutoCaptureActive) {
                toggleAutoCaptureBtn.classList.add('active');
                toggleAutoCaptureBtn.textContent = 'Auto Capture: ON';
                lastAutoCaptureTime = 0; // Reset cooldown on activation
                updateMessageBox('Auto capture is ON. Position hand for capture.', 'info');
            } else {
                toggleAutoCaptureBtn.classList.remove('active');
                toggleAutoCaptureBtn.textContent = 'Auto Capture: OFF';
                updateMessageBox('Auto capture is OFF. Use manual capture button.', 'info');
            }
        });


        // --- Initial Load ---
        window.onload = async () => {
            await loadHandposeModel(); // Load the ML model once when the page loads
            // Initial render of empty galleries
            renderPhotos('left');
            renderPhotos('right');
        };

        // Cleanup: Stop camera stream if the page is closed (as a fallback, modal close handles it too)
        window.addEventListener('beforeunload', () => {
            stopCamera();
        });
    </script>
</body>
</html>
