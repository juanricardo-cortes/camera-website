<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Palm Photo Capture with Custom Camera</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- TensorFlow.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <!-- MediaPipe Hands CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js"></script>
    <!-- HandPose model from TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose@0.0.7/dist/handpose.min.js"></script>

    <style>
        /* Custom styles for better visual appeal */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px; /* Add some padding for smaller screens */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }

        /* User's original palm upload container styles */
        .palm-upload-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }
        /* New container for each palm box and its buttons */
        .palm-input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px; /* Space between box and buttons */
        }

        .upload-box {
            border: 2px dashed #d7bfb9;
            border-radius: 8px;
            width: 180px;
            height: 180px; /* Increased height to accommodate image */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            background-color: #fffaf8;
            font-family: sans-serif;
            font-size: 14px;
            color: #7a3e2f;
            text-align: center;
            position: relative; /* For positioning captured image */
            overflow: hidden; /* Hide overflow for rounded corners */
            padding: 10px; /* Add padding inside the box */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }
        .upload-box .placeholder-text {
            display: flex; /* Ensure flex for centering */
            align-items: center;
            justify-content: center;
            height: 100%; /* Occupy full height when no images */
            width: 100%;
            padding: 0 5px;
            box-sizing: border-box;
        }
        .upload-box .photo-gallery {
            display: flex;
            flex-wrap: wrap;
            gap: 5px; /* Small gap between images */
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%; /* Fill the upload-box */
            overflow-y: auto; /* Allow scrolling if many photos */
            padding: 5px; /* Padding inside gallery */
            box-sizing: border-box;
        }
        .photo-card {
            position: relative;
            width: 70px; /* Thumbnail size */
            height: 70px;
            border: 1px solid #ccc;
            border-radius: 4px;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0; /* Prevent cards from shrinking */
        }
        .photo-card img {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Cover the thumbnail area */
            border-radius: 4px;
        }
        .photo-card .delete-photo-btn {
            position: absolute;
            top: 2px;
            right: 2px;
            background-color: rgba(239, 68, 68, 0.8); /* Red with transparency */
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            line-height: 1;
            padding: 0;
            opacity: 0.8;
            transition: opacity 0.2s;
            z-index: 10; /* Ensure button is above image */
        }
        .photo-card .delete-photo-btn:hover {
            opacity: 1;
        }

        /* Styles for the buttons now they are outside the box */
        button.capture-trigger-btn,
        button.remove-image-btn {
            background-color: #4f46e5;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.06);
            border: none;
            flex-shrink: 0;
            width: 100%; /* Make buttons full width of the group */
            max-width: 180px; /* Match upload-box width */
        }
        button.capture-trigger-btn:hover,
        button.remove-image-btn:hover {
            background-color: #4338ca;
            transform: translateY(-1px);
        }
        button.remove-image-btn {
            background-color: #ef4444; /* Red color for remove button */
        }
        button.remove-image-btn:hover {
            background-color: #dc2626;
        }

        /* Modal specific styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .modal.show {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.08);
            max-width: 95vw; /* Responsive width for modal */
            width: 500px; /* Max width for desktop */
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .modal-header {
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e5e7eb;
        }
        .modal-header h2 {
            font-size: 1.25rem;
            font-weight: 700;
            color: #374151;
        }
        .modal-close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6b7280;
            transition: color 0.2s;
        }
        .modal-close-btn:hover {
            color: #1f2937;
        }

        /* Camera app specific styles (from previous version, adapted for modal) */
        .camera-area {
            position: relative;
            width: 100%;
            /* Default to landscape 4:3 aspect ratio for desktop */
            padding-top: 75%; /* (height / width) * 100% = (3/4) * 100% */
            overflow: hidden;
            background-color: #000;
        }

        /* Adjust for mobile portrait (e.g., up to 768px width) */
        @media (max-width: 768px) {
            .camera-area {
                /* For portrait, use a 3:4 aspect ratio (height > width) */
                padding-top: 133.33%; /* (4/3) * 100% */
            }
        }

        video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            /* transform: scaleX(-1); This will be set dynamically by JS */
        }
        #hiddenCanvas, #motionDetectionCanvas {
            display: none;
        }
        .hand-outline-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%; /* Changed from 60% to 90% */
            height: 90%; /* Changed from 60% to 90% */
            border: 4px solid;
            border-radius: 1rem;
            pointer-events: none;
            transition: border-color 0.3s ease-in-out;
            overflow: hidden; /* Crucial to contain the scanning line */
        }
        .red-outline {
            border-color: #ef4444;
        }
        .green-outline {
            border-color: #22c55e;
        }
        /* Scanning line effect */
        .hand-outline-overlay::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%; /* Start off-screen to the left */
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(34, 197, 94, 0.3), transparent); /* Green gradient */
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        .hand-outline-overlay.scanning::after {
            opacity: 1;
            animation: scan-line 2s infinite linear; /* Animate the scan line */
        }

        @keyframes scan-line {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .controls {
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .button-group {
            display: flex;
            justify-content: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        /* New class to control visibility of zoom options */
        .zoom-controls-group {
            display: flex; /* Default to flex */
            justify-content: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        /* Hide zoom controls if not supported */
        .zoom-controls-group.hidden-zoom {
            display: none;
        }

        button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: none;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.06), 0 1px 2px -1px rgba(0, 0, 0, 0.04);
        }
        .btn-primary {
            background-color: #4f46e5;
            color: white;
        }
        .btn-primary:hover {
            background-color: #4338ca;
        }
        .btn-secondary {
            background-color: #e5e7eb;
            color: #374151;
        }
        .btn-secondary:hover {
            background-color: #d1d5db;
        }
        .btn-capture {
            background-color: #10b981;
            color: white;
        }
        .btn-capture:hover {
            background-color: #059669;
        }
        .btn-toggle-auto-capture {
            background-color: #6366f1; /* Indigo for toggle */
            color: white;
        }
        .btn-toggle-auto-capture.active {
            background-color: #10b981; /* Green when active */
        }
        .btn-toggle-auto-capture:hover {
            background-color: #4f46e5;
        }
        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 8px;
            background: #e0e7ff;
            border-radius: 5px;
            outline: none;
            transition: opacity .2s;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4f46e5;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4f46e5;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        /* Style for the zoom slider label */
        .zoom-slider-label {
            display: block; /* Ensure it takes its own line */
            text-align: center;
            color: #374151;
            font-weight: 500;
        }
        /* Hide the zoom slider label if zoom is not supported */
        .zoom-slider-label.hidden-zoom {
            display: none;
        }

        #message-box {
            padding: 0.75rem;
            border-radius: 0.5rem;
            text-align: center;
            font-size: 0.875rem;
            display: none;
            margin-bottom: 0.5rem;
        }
        .message-info {
            background-color: #e0e7ff;
            color: #4f46e5;
        }
        .message-warning {
            background-color: #fffbeb;
            color: #f59e0b;
        }
        .message-error {
            background-color: #fef2f2;
            color: #ef4444;
        }
        .message-success {
            background-color: #ecfdf5;
            color: #10b981;
        }
    </style>
</head>
<body>

    <div class="palm-upload-container">
        <div class="palm-input-group">
            <div class="upload-box" id="leftPalmBox">
                <!-- This input will now hold a JSON string of Data URLs -->
                <input type="hidden" id="leftPalmInput" name="leftPalmPhoto" />
                <span id="leftPalmText" class="placeholder-text">Left Palm Photo *</span>
                <div class="photo-gallery" id="leftPalmGallery">
                    <!-- Captured images will be appended here -->
                </div>
            </div>
            <button class="capture-trigger-btn" data-palm="left">Capture Left Palm</button>
            <button class="remove-image-btn hidden" data-palm="left">Remove Left Palm</button>
        </div>

        <div class="palm-input-group">
            <div class="upload-box" id="rightPalmBox">
                <!-- This input will now hold a JSON string of Data URLs -->
                <input type="hidden" id="rightPalmInput" name="rightPalmPhoto" />
                <span id="rightPalmText" class="placeholder-text">Right Palm Photo *</span>
                <div class="photo-gallery" id="rightPalmGallery">
                    <!-- Captured images will be appended here -->
                </div>
            </div>
            <button class="capture-trigger-btn" data-palm="right">Capture Right Palm</button>
            <button class="remove-image-btn hidden" data-palm="right">Remove Right Palm</button>
        </div>
    </div>

    <!-- The Modal for Camera Application -->
    <div id="cameraModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Capture Palm Photo</h2>
                <button class="modal-close-btn" id="closeModalBtn">&times;</button>
            </div>
            <div class="camera-area">
                <video id="cameraFeed" autoplay playsinline></video>
                <canvas id="hiddenCanvas"></canvas>
                <canvas id="motionDetectionCanvas"></canvas> <!-- New: Canvas for motion detection -->
                <div id="handOutlineOverlay" class="hand-outline-overlay red-outline"></div>
            </div>
            <div class="controls">
                <div id="message-box" class="message-info"></div>
                <div class="button-group">
                    <button id="captureBtn" class="btn-capture" disabled>Capture Image</button>
                    <button id="toggleCameraBtn" class="btn-secondary">Toggle Camera</button>
                    <button id="toggleAutoCaptureBtn" class="btn-toggle-auto-capture">Toggle Auto Capture</button>
                </div>
                <!-- Zoom controls group -->
                <div id="zoomControlsGroup" class="zoom-controls-group">
                    <button id="zoomOutBtn" class="btn-secondary">Zoom Out</button>
                    <button id="zoomInBtn" class="btn-primary">Zoom In</button>
                </div>
                <label for="zoomSlider" id="zoomSliderLabel" class="zoom-slider-label">Zoom Level:</label>
                <input type="range" id="zoomSlider" min="0" max="100" value="0" class="w-full" disabled>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const cameraModal = document.getElementById('cameraModal');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const modalTitle = document.getElementById('modalTitle');
        const captureTriggerButtons = document.querySelectorAll('.palm-input-group .capture-trigger-btn');
        const removeImageButtons = document.querySelectorAll('.palm-input-group .remove-image-btn'); // New: Added reference to remove buttons

        const cameraFeed = document.getElementById('cameraFeed');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomSlider = document.getElementById('zoomSlider');
        const zoomSliderLabel = document.getElementById('zoomSliderLabel');
        const zoomControlsGroup = document.getElementById('zoomControlsGroup');

        const messageBox = document.getElementById('message-box');
        const handOutlineOverlay = document.getElementById('handOutlineOverlay');
        const hiddenCanvas = document.getElementById('hiddenCanvas');
        const ctx = hiddenCanvas.getContext('2d');
        const motionDetectionCanvas = document.getElementById('motionDetectionCanvas');
        const motionDetectionCtx = motionDetectionCanvas.getContext('2d');
        const captureBtn = document.getElementById('captureBtn');
        const toggleCameraBtn = document.getElementById('toggleCameraBtn');
        const toggleAutoCaptureBtn = document.getElementById('toggleAutoCaptureBtn');

        // References for left palm elements
        const leftPalmInput = document.getElementById('leftPalmInput');
        const leftPalmText = document.getElementById('leftPalmText');
        const leftPalmGallery = document.getElementById('leftPalmGallery');

        // References for right palm elements
        const rightPalmInput = document.getElementById('rightPalmInput');
        const rightPalmText = document.getElementById('rightPalmText');
        const rightPalmGallery = document.getElementById('rightPalmGallery');

        // --- State Variables ---
        let mediaStream = null;
        let videoTrack = null;
        let zoomCapabilities = null;
        let currentZoom = 0;
        let isHandDetected = false;
        let lightingCondition = 'unknown'; // 'good', 'low', 'high', 'poor_contrast'
        let isHandSteady = true;
        let handposeModel = null;
        let currentPalmTarget = null;
        let animationFrameId = null;
        let currentFacingMode = 'user'; // 'user' for front camera, 'environment' for back camera

        let isAutoCaptureActive = false;
        const autoCaptureCooldown = 3000; // 3 seconds cooldown between auto-captures
        let lastAutoCaptureTime = 0;
        let scanCompletionTimeoutId = null;
        const scanDuration = 1500; // 1.5 seconds

        // Motion detection variables
        let lastFrameData = null;
        // Increased threshold for less sensitivity, adjust as needed.
        // This value might need further fine-tuning based on device, lighting, and expected motion.
        const MOTION_THRESHOLD = 50000; // Significantly increased threshold

        // Arrays to store captured image Data URLs for each palm (will be uploaded by footer script)
        let leftPalmPhotos = [];
        let rightPalmPhotos = [];

        // Lighting thresholds (adjust as needed for your environment)
        const LOW_BRIGHTNESS_THRESHOLD = 60;
        const HIGH_BRIGHTNESS_THRESHOLD = 180;
        const MIN_CONTRAST_THRESHOLD = 30;

        // --- Utility Functions ---

        /**
         * Displays a message in the message box.
         * @param {string} message - The message to display.
         * @param {string} type - The type of message ('info', 'warning', 'error', 'success').
         */
        function updateMessageBox(message, type = 'info') {
            messageBox.textContent = message;
            messageBox.style.display = 'block';
            messageBox.className = `message-box message-${type}`;
        }

        /**
         * Initializes the camera feed and sets up zoom controls.
         */
        async function initCamera() {
            try {
                // Stop any existing camera stream first
                stopCamera();

                const videoConstraints = {
                    facingMode: currentFacingMode
                };

                mediaStream = await navigator.mediaDevices.getUserMedia({ video: videoConstraints });
                cameraFeed.srcObject = mediaStream;

                cameraFeed.style.transform = (currentFacingMode === 'user') ? 'scaleX(-1)' : 'none';

                videoTrack = mediaStream.getVideoTracks()[0];

                const capabilities = videoTrack.getCapabilities();
                if (capabilities.zoom) {
                    zoomCapabilities = capabilities.zoom;
                    zoomSlider.min = zoomCapabilities.min;
                    zoomSlider.max = zoomCapabilities.max;
                    zoomSlider.step = zoomCapabilities.step;
                    currentZoom = zoomCapabilities.min;
                    zoomSlider.value = currentZoom;
                    // Ensure zoom controls are visible
                    zoomControlsGroup.classList.remove('hidden-zoom');
                    zoomSliderLabel.classList.remove('hidden-zoom');
                    zoomSlider.classList.remove('hidden-zoom');
                    zoomInBtn.disabled = false;
                    zoomOutBtn.disabled = false;
                    zoomSlider.disabled = false;
                    updateZoomDisplay();
                    updateMessageBox('Camera ready. Zoom controls available.', 'info');
                    console.log('Zoom capabilities:', zoomCapabilities);
                } else {
                    updateMessageBox('Zoom is not supported by your camera or browser.', 'warning');
                    // Hide zoom controls
                    zoomControlsGroup.classList.add('hidden-zoom');
                    zoomSliderLabel.classList.add('hidden-zoom');
                    zoomSlider.classList.add('hidden-zoom');
                    zoomInBtn.disabled = true;
                    zoomOutBtn.disabled = true;
                    zoomSlider.disabled = true;
                    console.log('Zoom not supported by device/browser.');
                }
                updateHandOutline();
                checkCaptureButtonState();

                cameraFeed.onloadedmetadata = () => {
                    motionDetectionCanvas.width = cameraFeed.videoWidth;
                    motionDetectionCanvas.height = cameraFeed.videoHeight;
                    startDetectionLoop();
                };

            }
            catch (error) {
                console.error('Error accessing camera:', error);
                if (error.name === 'NotAllowedError') {
                    updateMessageBox('Camera access denied. Please allow camera access in your browser settings.', 'error');
                } else if (error.name === 'NotFoundError') {
                    updateMessageBox('No camera found on your device.', 'error');
                } else if (error.name === 'OverconstrainedError') {
                    updateMessageBox('Requested camera not available. Trying default camera.', 'warning');
                    currentFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user';
                    initCamera();
                }
                else {
                    updateMessageBox(`Error: ${error.message}. Could not access camera.`, 'error');
                }
                // Always hide zoom controls if camera init fails
                zoomControlsGroup.classList.add('hidden-zoom');
                zoomSliderLabel.classList.add('hidden-zoom');
                zoomSlider.classList.add('hidden-zoom');
                zoomInBtn.disabled = true;
                zoomOutBtn.disabled = true;
                zoomSlider.disabled = true;
                captureBtn.disabled = true;
            }
        }

        /**
         * Stops the camera feed and cancels the animation loop.
         */
        function stopCamera() {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                cameraFeed.srcObject = null;
                mediaStream = null;
                videoTrack = null;
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            if (scanCompletionTimeoutId) {
                clearTimeout(scanCompletionTimeoutId);
                scanCompletionTimeoutId = null;
            }
            lastFrameData = null;
            isHandSteady = true;
        }

        /**
         * Applies the new zoom level to the video track.
         * @param {number} newZoom - The desired zoom level.
         */
        function applyZoom(newZoom) {
            if (!videoTrack || !zoomCapabilities) {
                updateMessageBox('Camera not ready or zoom not supported.', 'warning');
                return;
            }

            newZoom = Math.max(zoomCapabilities.min, Math.min(newZoom, zoomCapabilities.max));
            console.log('Attempting to apply zoom:', newZoom);

            videoTrack.applyConstraints({
                advanced: [{ zoom: newZoom }]
            }).then(() => {
                currentZoom = newZoom;
                zoomSlider.value = currentZoom;
                updateZoomDisplay();
                console.log('Zoom applied successfully to:', currentZoom);
            }).catch(error => {
                console.error('Error applying zoom:', error);
                updateMessageBox(`Failed to apply zoom: ${error.message}`, 'error');
            });
        }

        /**
         * Updates the zoom slider and potentially a text display (if added).
         */
        function updateZoomDisplay() {
            // Placeholder
        }

        /**
         * Updates the hand outline color based on the isHandDetected state.
         */
        function updateHandOutline() {
            if (isHandDetected) {
                handOutlineOverlay.classList.remove('red-outline');
                handOutlineOverlay.classList.add('green-outline');
            } else {
                handOutlineOverlay.classList.remove('green-outline');
                handOutlineOverlay.classList.add('red-outline');
            }
            if (isHandDetected && lightingCondition === 'good' && isHandSteady) {
                handOutlineOverlay.classList.add('scanning');
            } else {
                handOutlineOverlay.classList.remove('scanning');
            }
        }

        /**
         * Analyzes the lighting condition from the provided ImageData, including contrast.
         * @param {ImageData} imageData - The image data from the canvas.
         * @returns {string} 'good', 'low', 'high', or 'poor_contrast'.
         */
        function analyzeLighting(imageData) {
            const data = imageData.data;
            let totalLuminance = 0;
            let luminances = [];
            const pixelCount = data.length / 4;

            if (pixelCount === 0) return 'unknown';

            for (let i = 0; i < data.length; i += 4) {
                const luminance = (data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114);
                totalLuminance += luminance;
                luminances.push(luminance);
            }
            const averageLuminance = totalLuminance / pixelCount;

            let variance = 0;
            for (let i = 0; i < luminances.length; i++) {
                variance += Math.pow(luminances[i] - averageLuminance, 2);
            }
            const luminanceStdDev = Math.sqrt(variance / luminances.length);

            if (averageLuminance < LOW_BRIGHTNESS_THRESHOLD) {
                return 'low';
            } else if (averageLuminance > HIGH_BRIGHTNESS_THRESHOLD) {
                return 'high';
            } else if (luminanceStdDev < MIN_CONTRAST_THRESHOLD) {
                return 'poor_contrast';
            } else {
                return 'good';
            }
        }

        /**
         * Detects motion by comparing current frame pixels to the last frame.
         * It focuses on the central area of the frame to reduce background noise.
         * @param {HTMLVideoElement} video - The video element.
         * @returns {boolean} True if motion is detected, false otherwise.
         */
        function detectMotion(video) {
            if (!video.videoWidth || !video.videoHeight) return false;

            // Use a smaller central region for motion detection
            const regionWidth = video.videoWidth * 0.8; // 80% of video width
            const regionHeight = video.videoHeight * 0.8; // 80% of video height
            const regionX = (video.videoWidth - regionWidth) / 2;
            const regionY = (video.videoHeight - regionHeight) / 2;

            motionDetectionCanvas.width = regionWidth;
            motionDetectionCanvas.height = regionHeight;
            // Draw only the central region to the motion detection canvas
            motionDetectionCtx.drawImage(video, regionX, regionY, regionWidth, regionHeight, 0, 0, regionWidth, regionHeight);
            const currentFrameData = motionDetectionCtx.getImageData(0, 0, regionWidth, regionHeight).data;

            if (!lastFrameData || lastFrameData.length !== currentFrameData.length) {
                lastFrameData = currentFrameData;
                return false; // No previous frame or dimensions changed
            }

            let difference = 0;
            // Compare a subset of pixels for performance, e.g., every 10th pixel
            for (let i = 0; i < currentFrameData.length; i += 40) { // Check every 10th pixel (4 bytes * 10)
                difference += Math.abs(currentFrameData[i] - lastFrameData[i]);
                difference += Math.abs(currentFrameData[i+1] - lastFrameData[i+1]);
                difference += Math.abs(currentFrameData[i+2] - lastFrameData[i+2]);
            }
            console.log("Motion difference (central region):", difference); // Log motion difference
            lastFrameData = currentFrameData;

            // Increased threshold for less sensitivity. This value might need further fine-tuning.
            return difference > MOTION_THRESHOLD;
        }


        /**
         * Updates the combined status message in the message box.
         */
        function updateCombinedStatusMessage() {
            let handStatus = isHandDetected ? 'Hand detected!' : 'No hand visible.';
            let lightingStatusText = '';
            let messageType = 'info';

            switch (lightingCondition) {
                case 'low':
                    lightingStatusText = 'Lighting is too low. Move to a brighter area.';
                    messageType = 'warning';
                    break;
                case 'high':
                    lightingStatusText = 'Lighting is too bright. Avoid glare.';
                    messageType = 'warning';
                    break;
                case 'poor_contrast':
                    lightingStatusText = 'Poor contrast. Adjust lighting to see details (e.g., lines).';
                    messageType = 'warning';
                    break;
                case 'good':
                    lightingStatusText = 'Lighting looks good for details.';
                    messageType = 'success';
                    break;
                default:
                    lightingStatusText = 'Analyzing lighting...';
                    messageType = 'info';
            }

            let motionStatusText = isHandSteady ? '' : 'Hold hand steady.';
            if (!isHandSteady) {
                messageType = 'warning';
            }

            const fullMessage = `${handStatus} ${lightingStatusText} ${motionStatusText}`.trim();
            updateMessageBox(fullMessage, messageType);
        }

        /**
         * Enables or disables the capture button based on hand detection, lighting, and stability.
         */
        function checkCaptureButtonState() {
            if (isHandDetected && lightingCondition === 'good' && isHandSteady) {
                captureBtn.disabled = false;
            } else {
                captureBtn.disabled = true;
            }
        }

        /**
         * Loads the Handpose model.
         */
        async function loadHandposeModel() {
            updateMessageBox('Loading hand detection model...', 'info');
            try {
                handposeModel = await handpose.load();
                updateMessageBox('Hand detection model loaded successfully!', 'info');
            } catch (error) {
                console.error('Error loading handpose model:', error);
                updateMessageBox('Failed to load hand detection model. Hand detection will not work.', 'error');
            }
        }

        /**
         * Starts the continuous hand and lighting detection loop.
         */
        async function startDetectionLoop() {
            if (!handposeModel || !cameraFeed.videoWidth || !cameraFeed.videoHeight || !mediaStream) {
                animationFrameId = requestAnimationFrame(startDetectionLoop);
                return;
            }

            isHandSteady = !detectMotion(cameraFeed);

            ctx.drawImage(cameraFeed, 0, 0, hiddenCanvas.width, hiddenCanvas.height);

            const imageData = ctx.getImageData(0, 0, hiddenCanvas.width, hiddenCanvas.height);
            lightingCondition = analyzeLighting(imageData);

            const predictions = await handposeModel.estimateHands(hiddenCanvas);

            isHandDetected = predictions.length > 0;

            updateHandOutline();
            updateCombinedStatusMessage();
            checkCaptureButtonState();

            if (isAutoCaptureActive) {
                const now = Date.now();
                const canCaptureNow = (now - lastAutoCaptureTime > autoCaptureCooldown);

                if (isHandDetected && lightingCondition === 'good' && isHandSteady) {
                    if (!scanCompletionTimeoutId && canCaptureNow) {
                        updateMessageBox('Scanning... Hold hand steady.', 'info');
                        scanCompletionTimeoutId = setTimeout(() => {
                            if (isHandDetected && lightingCondition === 'good' && isHandSteady) {
                                captureImage(); // Now this just captures to Data URL
                                lastAutoCaptureTime = Date.now();
                            } else {
                                updateMessageBox('Scan interrupted. Conditions changed or hand moved.', 'warning');
                            }
                            scanCompletionTimeoutId = null;
                        }, scanDuration);
                    }
                } else {
                    if (scanCompletionTimeoutId) {
                        clearTimeout(scanCompletionTimeoutId);
                        scanCompletionTimeoutId = null;
                        updateMessageBox('Scan cancelled. Adjust hand, lighting, or hold steady.', 'warning');
                    }
                }
            } else {
                if (scanCompletionTimeoutId) {
                    clearTimeout(scanCompletionTimeoutId);
                    scanCompletionTimeoutId = null;
                }
            }

            animationFrameId = requestAnimationFrame(startDetectionLoop);
        }

        /**
         * Applies a simple contrast/sharpening filter to the canvas context.
         * @param {CanvasRenderingContext2D} context - The 2D context of the canvas.
         * @param {number} amount - The intensity of the filter.
         */
        function applyContrastFilter(context, amount) {
            const imageData = context.getImageData(0, 0, context.canvas.width, context.canvas.height);
            const pixels = imageData.data;
            const factor = (259 * (amount + 255)) / (255 * (259 - amount));

            for (let i = 0; i < pixels.length; i += 4) {
                pixels[i] = factor * (pixels[i] - 128) + 128;
                pixels[i + 1] = factor * (pixels[i + 1] - 128) + 128;
                pixels[i + 2] = factor * (pixels[i + 2] - 128) + 128;
            }
            context.putImageData(imageData, 0, 0);
        }


        /**
         * Captures the current frame from the camera feed, processes it,
         * and stores the Data URL locally. Upload to Cloudinary happens on form submission.
         */
        function captureImage() {
            if (!cameraFeed.srcObject) {
                updateMessageBox('Camera not active. Cannot capture image.', 'error');
                return;
            }
            if (!isAutoCaptureActive && captureBtn.disabled) {
                updateMessageBox('Cannot capture: Hand not detected, lighting is poor, or hand is moving.', 'warning');
                return;
            }

            updateMessageBox('Capturing image...', 'info');
            captureBtn.disabled = true;

            try {
                const videoNativeWidth = cameraFeed.videoWidth;
                const videoNativeHeight = cameraFeed.videoHeight;
                const displayWidth = cameraFeed.offsetWidth;
                const displayHeight = cameraFeed.offsetHeight;

                hiddenCanvas.width = displayWidth;
                hiddenCanvas.height = displayHeight;
                ctx.clearRect(0, 0, hiddenCanvas.width, hiddenCanvas.height);

                const tempRawCanvas = document.createElement('canvas');
                const tempRawCtx = tempRawCanvas.getContext('2d');
                tempRawCanvas.width = videoNativeWidth;
                tempRawCanvas.height = videoNativeHeight;
                tempRawCtx.drawImage(cameraFeed, 0, 0, videoNativeWidth, videoNativeHeight);

                const isRawVideoPortrait = videoNativeHeight > videoNativeWidth;
                const isDisplayLandscape = displayWidth > displayHeight;

                let sourceForCropping = tempRawCanvas;
                let sourceForCroppingWidth = videoNativeWidth;
                let sourceForCroppingHeight = videoNativeHeight;

                if (isRawVideoPortrait && isDisplayLandscape) {
                    const rotatedSourceCanvas = document.createElement('canvas');
                    const rotatedSourceCtx = rotatedSourceCanvas.getContext('2d');
                    rotatedSourceCanvas.width = videoNativeHeight;
                    rotatedSourceCanvas.height = videoNativeWidth;
                    rotatedSourceCtx.save();
                    rotatedSourceCtx.translate(rotatedSourceCanvas.width / 2, rotatedSourceCanvas.height / 2);
                    rotatedSourceCtx.rotate(90 * Math.PI / 180);
                    rotatedSourceCtx.drawImage(tempRawCanvas, -videoNativeWidth / 2, -videoNativeHeight / 2, videoNativeWidth, videoNativeHeight);
                    rotatedSourceCtx.restore();
                    sourceForCropping = rotatedSourceCanvas;
                    sourceForCroppingWidth = rotatedSourceCanvas.width;
                    sourceForCroppingHeight = rotatedSourceCanvas.height;
                }

                const sourceAspectRatio = sourceForCroppingWidth / sourceForCroppingHeight;
                const targetAspectRatio = displayWidth / displayHeight;

                let sx = 0, sy = 0;
                let sCropWidth = sourceForCroppingWidth;
                let sCropHeight = sourceForCroppingHeight;

                if (sourceAspectRatio > targetAspectRatio) {
                    sCropHeight = sourceForCroppingHeight;
                    sCropWidth = sCropHeight * targetAspectRatio;
                    sx = (sourceForCroppingWidth - sCropWidth) / 2;
                    sy = 0;
                } else {
                    sCropWidth = sourceForCroppingWidth;
                    sCropHeight = sCropWidth / targetAspectRatio;
                    sy = (sourceForCroppingHeight - sCropHeight) / 2;
                    sx = 0;
                }

                ctx.save();
                if (currentFacingMode === 'user') {
                    ctx.translate(hiddenCanvas.width, 0);
                    ctx.scale(-1, 1);
                }
                ctx.drawImage(sourceForCropping, sx, sy, sCropWidth, sCropHeight, 0, 0, hiddenCanvas.width, hiddenCanvas.height);
                ctx.restore();

                applyContrastFilter(ctx, 50);

                const imageDataUrl = hiddenCanvas.toDataURL('image/png');

                if (currentPalmTarget === 'left') {
                    leftPalmPhotos.push(imageDataUrl);
                    renderPhotos('left');
                } else if (currentPalmTarget === 'right') {
                    rightPalmPhotos.push(imageDataUrl);
                    renderPhotos('right');
                }

                updateMessageBox('Image captured successfully! It will be uploaded on form submission.', 'success');

            } catch (error) {
                console.error('Capture Error:', error);
                updateMessageBox(`Error capturing image: ${error.message}`, 'error');
            } finally {
                captureBtn.disabled = false;
            }
        }

        /**
         * Renders the photos for a given palm into its gallery.
         * @param {string} palm - 'left' or 'right'.
         */
        function renderPhotos(palm) {
            let galleryElement, photosArray, textElement, inputElement;

            if (palm === 'left') {
                galleryElement = leftPalmGallery;
                photosArray = leftPalmPhotos;
                textElement = leftPalmText;
                inputElement = leftPalmInput;
            } else if (palm === 'right') {
                galleryElement = rightPalmGallery;
                photosArray = rightPalmPhotos;
                textElement = rightPalmText;
                inputElement = rightPalmInput;
            }

            galleryElement.innerHTML = '';

            if (photosArray.length === 0) {
                textElement.style.display = 'flex';
            } else {
                textElement.style.display = 'none';
                photosArray.forEach((dataUrl, index) => {
                    const photoCard = document.createElement('div');
                    photoCard.classList.add('photo-card');
                    photoCard.dataset.index = index;

                    const img = document.createElement('img');
                    img.src = dataUrl;
                    img.alt = `${palm} Palm Photo ${index + 1}`;

                    const deleteBtn = document.createElement('button');
                    deleteBtn.classList.add('delete-photo-btn');
                    deleteBtn.textContent = 'x';
                    deleteBtn.title = 'Remove photo';
                    deleteBtn.addEventListener('click', (event) => {
                        event.stopPropagation();
                        removePhoto(palm, index);
                    });

                    photoCard.appendChild(img);
                    photoCard.appendChild(deleteBtn);
                    galleryElement.appendChild(photoCard);
                });
            }
            inputElement.value = JSON.stringify(photosArray);
        }

        /**
         * Removes a specific photo from the gallery and updates the data.
         * @param {string} palm - 'left' or 'right'.
         * @param {number} index - The index of the photo to remove.
         */
        function removePhoto(palm, index) {
            let photosArray;
            if (palm === 'left') {
                photosArray = leftPalmPhotos;
            } else if (palm === 'right') {
                photosArray = rightPalmPhotos;
            }

            if (index > -1 && index < photosArray.length) {
                photosArray.splice(index, 1);
                renderPhotos(palm);
                updateMessageBox(`${palm === 'left' ? 'Left' : 'Right'} palm photo removed.`, 'info');
            }
        }

        // --- Modal Control Functions ---

        /**
         * Opens the camera modal and initializes the camera.
         * @param {string} palm - 'left' or 'right' to indicate which palm is being captured.
         */
        async function openCameraModal(palm) {
            currentPalmTarget = palm;
            modalTitle.textContent = `Capture ${palm === 'left' ? 'Left' : 'Right'} Palm Photo`;
            cameraModal.classList.add('show');
            await initCamera();
        }

        /**
         * Closes the camera modal and stops the camera.
         */
        function closeCameraModal() {
            cameraModal.classList.remove('show');
            stopCamera();
            currentPalmTarget = null;
            updateMessageBox('', 'info');
        }

        // --- Event Listeners ---

        captureTriggerButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                const palm = event.target.dataset.palm;
                openCameraModal(palm);
            });
        });

        closeModalBtn.addEventListener('click', closeCameraModal);

        zoomInBtn.addEventListener('click', () => {
            if (zoomCapabilities) {
                let newZoom = currentZoom + (zoomCapabilities.step || (zoomCapabilities.max - zoomCapabilities.min) / 10);
                applyZoom(newZoom);
            }
        });

        zoomOutBtn.addEventListener('click', () => {
            if (zoomCapabilities) {
                let newZoom = currentZoom - (zoomCapabilities.step || (zoomCapabilities.max - zoomCapabilities.min) / 10);
                applyZoom(newZoom);
            }
        });

        zoomSlider.addEventListener('input', (event) => {
            if (zoomCapabilities) {
                const newZoom = parseFloat(event.target.value);
                applyZoom(newZoom);
            }
        });

        captureBtn.addEventListener('click', captureImage);

        toggleCameraBtn.addEventListener('click', () => {
            currentFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user';
            initCamera();
        });

        toggleAutoCaptureBtn.addEventListener('click', () => {
            isAutoCaptureActive = !isAutoCaptureActive;
            if (isAutoCaptureActive) {
                toggleAutoCaptureBtn.classList.add('active');
                toggleAutoCaptureBtn.textContent = 'Auto Capture: ON';
                lastAutoCaptureTime = 0;
                updateMessageBox('Auto capture is ON. Position hand for capture.', 'info');
            } else {
                toggleAutoCaptureBtn.classList.remove('active');
                toggleAutoCaptureBtn.textContent = 'Auto Capture: OFF';
                updateMessageBox('Auto capture is OFF. Use manual capture button.', 'info');
            }
        });


        // --- Initial Load ---
        window.onload = async () => {
            await loadHandposeModel();
            renderPhotos('left');
            renderPhotos('right');
        };

        window.addEventListener('beforeunload', () => {
            stopCamera();
        });
    </script>
</body>
</html>
