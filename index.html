<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Palm Photo Capture with Custom Camera</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- TensorFlow.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <!-- MediaPipe Hands CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js"></script>
    <!-- HandPose model from TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose@0.0.7/dist/handpose.min.js"></script>

    <style>
        /* Custom styles for better visual appeal */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px; /* Add some padding for smaller screens */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }

        /* User's original palm upload container styles */
        .palm-upload-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }
        .upload-box {
            border: 2px dashed #d7bfb9;
            border-radius: 8px;
            width: 180px;
            height: 180px; /* Increased height to accommodate image */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            background-color: #fffaf8;
            font-family: sans-serif;
            font-size: 14px;
            color: #7a3e2f;
            text-align: center;
            position: relative; /* For positioning captured image */
            overflow: hidden; /* Hide overflow for rounded corners */
            padding: 10px; /* Add padding inside the box */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }
        .upload-box span {
            margin-top: 10px;
            display: block; /* Ensure span takes full width */
            padding: 0 5px; /* Add padding to text */
            flex-grow: 1; /* Allow text to take available space */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .upload-box img {
            max-width: 100%; /* Ensure image fits */
            max-height: 100%; /* Ensure image fits */
            object-fit: contain; /* Contain the image within the box */
            border-radius: 8px;
            display: none; /* Hidden by default */
            margin-bottom: 5px; /* Space between image and button */
        }
        .upload-box button.capture-trigger-btn,
        .upload-box button.remove-image-btn {
            background-color: #4f46e5;
            color: white;
            padding: 0.5rem 1rem; /* Slightly smaller padding for these buttons */
            border-radius: 0.5rem; /* Slightly smaller border-radius */
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.06);
            border: none;
            flex-shrink: 0; /* Prevent button from shrinking */
        }
        .upload-box button.capture-trigger-btn:hover,
        .upload-box button.remove-image-btn:hover {
            background-color: #4338ca;
            transform: translateY(-1px); /* Smaller lift on hover */
        }
        .upload-box button.remove-image-btn {
            background-color: #ef4444; /* Red color for remove button */
        }
        .upload-box button.remove-image-btn:hover {
            background-color: #dc2626;
        }

        /* Modal specific styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .modal.show {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.2), 0 10px 10px -5px rgba(0, 0, 0, 0.08);
            max-width: 95vw; /* Responsive width for modal */
            width: 500px; /* Max width for desktop */
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .modal-header {
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e5e7eb;
        }
        .modal-header h2 {
            font-size: 1.25rem;
            font-weight: 700;
            color: #374151;
        }
        .modal-close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6b7280;
            transition: color 0.2s;
        }
        .modal-close-btn:hover {
            color: #1f2937;
        }

        /* Camera app specific styles (from previous version, adapted for modal) */
        .camera-area {
            position: relative;
            width: 100%;
            padding-top: 75%; /* 4:3 aspect ratio */
            overflow: hidden;
            background-color: #000;
        }
        video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            transform: scaleX(-1); /* Mirror for selfie view */
        }
        #hiddenCanvas {
            display: none;
        }
        .hand-outline-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60%;
            height: 60%;
            border: 4px solid;
            border-radius: 1rem;
            pointer-events: none;
            transition: border-color 0.3s ease-in-out;
        }
        .red-outline {
            border-color: #ef4444;
        }
        .green-outline {
            border-color: #22c55e;
        }
        .controls {
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .button-group {
            display: flex;
            justify-content: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: none;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.06), 0 1px 2px -1px rgba(0, 0, 0, 0.04);
        }
        .btn-primary {
            background-color: #4f46e5;
            color: white;
        }
        .btn-primary:hover {
            background-color: #4338ca;
        }
        .btn-secondary {
            background-color: #e5e7eb;
            color: #374151;
        }
        .btn-secondary:hover {
            background-color: #d1d5db;
        }
        .btn-capture {
            background-color: #10b981;
            color: white;
        }
        .btn-capture:hover {
            background-color: #059669;
        }
        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 8px;
            background: #e0e7ff;
            border-radius: 5px;
            outline: none;
            transition: opacity .2s;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4f46e5;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4f46e5;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        #message-box {
            padding: 0.75rem;
            border-radius: 0.5rem;
            text-align: center;
            font-size: 0.875rem;
            display: none;
            margin-bottom: 0.5rem;
        }
        .message-info {
            background-color: #e0e7ff;
            color: #4f46e5;
        }
        .message-warning {
            background-color: #fffbeb;
            color: #f59e0b;
        }
        .message-error {
            background-color: #fef2f2;
            color: #ef4444;
        }
        .message-success {
            background-color: #ecfdf5;
            color: #10b981;
        }
    </style>
</head>
<body>

    <div class="palm-upload-container">
        <div class="upload-box" id="leftPalmBox">
            <input type="hidden" id="leftPalmInput" name="leftPalmPhoto" />
            <img id="leftPalmPreview" src="" alt="Left Palm Preview">
            <span id="leftPalmText">Left Palm Photo *</span>
            <button class="capture-trigger-btn" data-palm="left">Capture Left Palm</button>
            <button class="remove-image-btn hidden" data-palm="left">Remove</button>
        </div>

        <div class="upload-box" id="rightPalmBox">
            <input type="hidden" id="rightPalmInput" name="rightPalmPhoto" />
            <img id="rightPalmPreview" src="" alt="Right Palm Preview">
            <span id="rightPalmText">Right Palm Photo *</span>
            <button class="capture-trigger-btn" data-palm="right">Capture Right Palm</button>
            <button class="remove-image-btn hidden" data-palm="right">Remove</button>
        </div>
    </div>

    <!-- The Modal for Camera Application -->
    <div id="cameraModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Capture Palm Photo</h2>
                <button class="modal-close-btn" id="closeModalBtn">&times;</button>
            </div>
            <div class="camera-area">
                <video id="cameraFeed" autoplay playsinline></video>
                <canvas id="hiddenCanvas"></canvas>
                <div id="handOutlineOverlay" class="hand-outline-overlay red-outline"></div>
            </div>
            <div class="controls">
                <div id="message-box" class="message-info"></div>
                <div class="button-group">
                    <button id="zoomOutBtn" class="btn-secondary">Zoom Out</button>
                    <button id="zoomInBtn" class="btn-primary">Zoom In</button>
                    <button id="captureBtn" class="btn-capture" disabled>Capture Image</button>
                </div>
                <label for="zoomSlider" class="text-center text-gray-700 font-medium">Zoom Level:</label>
                <input type="range" id="zoomSlider" min="0" max="100" value="0" class="w-full" disabled>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const cameraModal = document.getElementById('cameraModal');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const modalTitle = document.getElementById('modalTitle');
        const captureTriggerButtons = document.querySelectorAll('.capture-trigger-btn');
        const removeImageButtons = document.querySelectorAll('.remove-image-btn'); // New: Remove buttons

        const cameraFeed = document.getElementById('cameraFeed');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomSlider = document.getElementById('zoomSlider');
        const messageBox = document.getElementById('message-box');
        const handOutlineOverlay = document.getElementById('handOutlineOverlay');
        const hiddenCanvas = document.getElementById('hiddenCanvas');
        const ctx = hiddenCanvas.getContext('2d');
        const captureBtn = document.getElementById('captureBtn');

        const leftPalmInput = document.getElementById('leftPalmInput');
        const leftPalmPreview = document.getElementById('leftPalmPreview');
        const leftPalmText = document.getElementById('leftPalmText');
        const leftPalmRemoveBtn = document.querySelector('#leftPalmBox .remove-image-btn'); // Specific remove button for left

        const rightPalmInput = document.getElementById('rightPalmInput');
        const rightPalmPreview = document.getElementById('rightPalmPreview');
        const rightPalmText = document.getElementById('rightPalmText');
        const rightPalmRemoveBtn = document.querySelector('#rightPalmBox .remove-image-btn'); // Specific remove button for right

        // --- State Variables ---
        let mediaStream = null;
        let videoTrack = null;
        let zoomCapabilities = null;
        let currentZoom = 0;
        let isHandDetected = false;
        let lightingCondition = 'unknown';
        let handposeModel = null;
        let currentPalmTarget = null; // 'left' or 'right'
        let animationFrameId = null; // To manage requestAnimationFrame loop

        // Lighting thresholds (adjust as needed for your environment)
        const LOW_BRIGHTNESS_THRESHOLD = 60;
        const HIGH_BRIGHTNESS_THRESHOLD = 180;

        // --- Utility Functions ---

        /**
         * Displays a message in the message box.
         * @param {string} message - The message to display.
         * @param {string} type - The type of message ('info', 'warning', 'error', 'success').
         */
        function updateMessageBox(message, type = 'info') {
            messageBox.textContent = message;
            messageBox.style.display = 'block';
            messageBox.className = `message-box message-${type}`;
        }

        /**
         * Initializes the camera feed and sets up zoom controls.
         */
        async function initCamera() {
            try {
                // Request access to the user's camera
                mediaStream = await navigator.mediaDevices.getUserMedia({ video: true });
                cameraFeed.srcObject = mediaStream;

                // Get the video track from the stream
                videoTrack = mediaStream.getVideoTracks()[0];

                // Check if zoom capabilities are supported by the video track
                const capabilities = videoTrack.getCapabilities();
                if (capabilities.zoom) {
                    zoomCapabilities = capabilities.zoom;
                    zoomSlider.min = zoomCapabilities.min;
                    zoomSlider.max = zoomCapabilities.max;
                    zoomSlider.step = zoomCapabilities.step;
                    currentZoom = zoomCapabilities.min;
                    zoomSlider.value = currentZoom;
                    zoomInBtn.disabled = false; // Enable zoom buttons
                    zoomOutBtn.disabled = false;
                    zoomSlider.disabled = false; // Enable zoom slider
                    updateZoomDisplay();
                    updateMessageBox('Camera ready. Zoom controls available.', 'info');
                    console.log('Zoom capabilities:', zoomCapabilities);
                } else {
                    updateMessageBox('Zoom is not supported by your camera or browser.', 'warning');
                    zoomInBtn.disabled = true;
                    zoomOutBtn.disabled = true;
                    zoomSlider.disabled = true;
                    console.log('Zoom not supported by device/browser.');
                }
                updateHandOutline(); // Set initial outline color to red
                checkCaptureButtonState(); // Initial check for capture button

                // Wait for the video to load metadata to get its dimensions
                cameraFeed.onloadedmetadata = () => {
                    // Start hand detection loop after camera is ready
                    startDetectionLoop();
                };

            } catch (error) {
                console.error('Error accessing camera:', error);
                if (error.name === 'NotAllowedError') {
                    updateMessageBox('Camera access denied. Please allow camera access in your browser settings.', 'error');
                } else if (error.name === 'NotFoundError') {
                    updateMessageBox('No camera found on your device.', 'error');
                } else {
                    updateMessageBox(`Error: ${error.message}. Could not access camera.`, 'error');
                }
                zoomInBtn.disabled = true;
                zoomOutBtn.disabled = true;
                zoomSlider.disabled = true;
                captureBtn.disabled = true;
            }
        }

        /**
         * Stops the camera feed and cancels the animation loop.
         */
        function stopCamera() {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                cameraFeed.srcObject = null;
                mediaStream = null;
                videoTrack = null;
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        /**
         * Applies the new zoom level to the video track.
         * @param {number} newZoom - The desired zoom level.
         */
        function applyZoom(newZoom) {
            if (!videoTrack || !zoomCapabilities) {
                updateMessageBox('Camera not ready or zoom not supported.', 'warning');
                return;
            }

            newZoom = Math.max(zoomCapabilities.min, Math.min(newZoom, zoomCapabilities.max));
            console.log('Attempting to apply zoom:', newZoom);

            videoTrack.applyConstraints({
                advanced: [{ zoom: newZoom }]
            }).then(() => {
                currentZoom = newZoom;
                zoomSlider.value = currentZoom;
                updateZoomDisplay();
                console.log('Zoom applied successfully to:', currentZoom);
            }).catch(error => {
                console.error('Error applying zoom:', error);
                updateMessageBox(`Failed to apply zoom: ${error.message}`, 'error');
            });
        }

        /**
         * Updates the zoom slider and potentially a text display (if added).
         */
        function updateZoomDisplay() {
            // This function is currently a placeholder.
            // You could add a text element here to show the current zoom value if desired.
        }

        /**
         * Updates the hand outline color based on the isHandDetected state.
         */
        function updateHandOutline() {
            if (isHandDetected) {
                handOutlineOverlay.classList.remove('red-outline');
                handOutlineOverlay.classList.add('green-outline');
            } else {
                handOutlineOverlay.classList.remove('green-outline');
                handOutlineOverlay.classList.add('red-outline');
            }
        }

        /**
         * Analyzes the lighting condition from the provided ImageData.
         * @param {ImageData} imageData - The image data from the canvas.
         * @returns {string} 'good', 'low', or 'high'.
         */
        function analyzeLighting(imageData) {
            const data = imageData.data;
            let totalBrightness = 0;
            const pixelCount = data.length / 4;

            if (pixelCount === 0) return 'unknown';

            for (let i = 0; i < data.length; i += 4) {
                totalBrightness += (data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114);
            }
            const averageBrightness = totalBrightness / pixelCount;

            if (averageBrightness < LOW_BRIGHTNESS_THRESHOLD) {
                return 'low';
            } else if (averageBrightness > HIGH_BRIGHTNESS_THRESHOLD) {
                return 'high';
            } else {
                return 'good';
            }
        }

        /**
         * Updates the combined status message in the message box.
         */
        function updateCombinedStatusMessage() {
            let handStatus = isHandDetected ? 'Hand detected!' : 'No hand visible.';
            let lightingStatusText = '';
            let messageType = 'info';

            switch (lightingCondition) {
                case 'low':
                    lightingStatusText = 'Lighting is too low. Move to a brighter area.';
                    messageType = 'warning';
                    break;
                case 'high':
                    lightingStatusText = 'Lighting is too bright. Avoid glare.';
                    messageType = 'warning';
                    break;
                case 'good':
                    lightingStatusText = 'Lighting looks good for details.';
                    messageType = 'success';
                    break;
                default:
                    lightingStatusText = 'Analyzing lighting...';
                    messageType = 'info';
            }

            const fullMessage = `${handStatus} ${lightingStatusText}`;
            updateMessageBox(fullMessage, messageType);
        }

        /**
         * Enables or disables the capture button based on hand detection and lighting.
         */
        function checkCaptureButtonState() {
            if (isHandDetected && lightingCondition === 'good') {
                captureBtn.disabled = false;
            } else {
                captureBtn.disabled = true;
            }
        }

        /**
         * Loads the Handpose model.
         */
        async function loadHandposeModel() {
            updateMessageBox('Loading hand detection model...', 'info');
            try {
                handposeModel = await handpose.load();
                updateMessageBox('Hand detection model loaded successfully!', 'info');
            } catch (error) {
                console.error('Error loading handpose model:', error);
                updateMessageBox('Failed to load hand detection model. Hand detection will not work.', 'error');
            }
        }

        /**
         * Starts the continuous hand and lighting detection loop.
         */
        async function startDetectionLoop() {
            if (!handposeModel || !cameraFeed.videoWidth || !cameraFeed.videoHeight || !mediaStream) {
                animationFrameId = requestAnimationFrame(startDetectionLoop); // Keep trying until camera is ready
                return;
            }

            // Draw the video frame onto the hidden canvas
            ctx.drawImage(cameraFeed, 0, 0, hiddenCanvas.width, hiddenCanvas.height);

            // Get image data for lighting analysis
            const imageData = ctx.getImageData(0, 0, hiddenCanvas.width, hiddenCanvas.height);
            lightingCondition = analyzeLighting(imageData);

            // Perform hand detection
            const predictions = await handposeModel.estimateHands(hiddenCanvas);

            // Determine if a hand is detected
            isHandDetected = predictions.length > 0;

            // Update UI based on detection and lighting
            updateHandOutline();
            updateCombinedStatusMessage();
            checkCaptureButtonState(); // Check button state in every frame

            animationFrameId = requestAnimationFrame(startDetectionLoop);
        }

        /**
         * Captures the current frame from the camera feed and displays it in the target palm box.
         */
        function captureImage() {
            if (!cameraFeed.srcObject) {
                updateMessageBox('Camera not active. Cannot capture image.', 'error');
                return;
            }
            if (captureBtn.disabled) {
                updateMessageBox('Cannot capture: Hand not detected or lighting is poor.', 'warning');
                return;
            }

            // Get intrinsic video dimensions
            const videoWidth = cameraFeed.videoWidth;
            const videoHeight = cameraFeed.videoHeight;

            // Get the displayed dimensions of the video element (which is the target size for the canvas)
            const displayWidth = cameraFeed.offsetWidth;
            const displayHeight = cameraFeed.offsetHeight;

            // Set hidden canvas dimensions to match the *displayed* video element's dimensions
            hiddenCanvas.width = displayWidth;
            hiddenCanvas.height = displayHeight;

            // Determine if the video stream is intrinsically portrait (height > width)
            const isVideoStreamPortrait = videoHeight > videoWidth;
            // Determine if the display area (camera-area) is landscape (width > height)
            const isDisplayLandscape = displayWidth > displayHeight;

            let sourceCanvas = document.createElement('canvas');
            let sourceCtx = sourceCanvas.getContext('2d');

            let finalSourceWidth = videoWidth;
            let finalSourceHeight = videoHeight;
            let finalSourceX = 0;
            let finalSourceY = 0;

            // Step 1: Draw the raw video frame onto a temporary canvas.
            // This temp canvas will hold the video data as it comes from the camera (e.g., portrait on phone).
            sourceCanvas.width = videoWidth;
            sourceCanvas.height = videoHeight;
            sourceCtx.drawImage(cameraFeed, 0, 0, videoWidth, videoHeight);

            // Step 2: Handle rotation if the video stream is portrait and display is landscape.
            // If rotation is needed, create another temporary canvas to hold the rotated version.
            if (isVideoStreamPortrait && isDisplayLandscape) {
                const rotatedCanvas = document.createElement('canvas');
                const rotatedCtx = rotatedCanvas.getContext('2d');

                rotatedCanvas.width = videoHeight; // Swap dimensions for rotation
                rotatedCanvas.height = videoWidth;

                rotatedCtx.save();
                rotatedCtx.translate(rotatedCanvas.width / 2, rotatedCanvas.height / 2);
                rotatedCtx.rotate(90 * Math.PI / 180); // Rotate 90 degrees clockwise
                rotatedCtx.drawImage(sourceCanvas, -sourceCanvas.width / 2, -sourceCanvas.height / 2);
                rotatedCtx.restore();

                // Now, the rotatedCanvas holds the correctly oriented source.
                sourceCanvas = rotatedCanvas; // Use this as our new source
                finalSourceWidth = rotatedCanvas.width;
                finalSourceHeight = rotatedCanvas.height;
            }

            // Step 3: Calculate cropping based on object-fit: cover for the final display aspect ratio.
            // Use the dimensions of the (potentially rotated) sourceCanvas.
            const sourceAspectRatio = finalSourceWidth / finalSourceHeight;
            const targetAspectRatio = displayWidth / displayHeight;

            if (sourceAspectRatio > targetAspectRatio) {
                // Source is wider than target, crop horizontally
                sHeight = finalSourceHeight;
                sWidth = sHeight * targetAspectRatio;
                sx = (finalSourceWidth - sWidth) / 2;
                sy = 0;
            } else {
                // Source is taller than or same aspect ratio as target, crop vertically
                sWidth = finalSourceWidth;
                sHeight = sWidth / targetAspectRatio;
                sy = (finalSourceHeight - sHeight) / 2;
                sx = 0;
            }

            // Step 4: Draw the cropped and oriented image to the hiddenCanvas, applying mirroring.
            ctx.save();
            ctx.translate(hiddenCanvas.width, 0); // Move origin to top-right
            ctx.scale(-1, 1); // Apply mirroring for selfie view

            // Draw from the (potentially rotated) sourceCanvas, with calculated cropping,
            // to fill the hiddenCanvas.
            ctx.drawImage(sourceCanvas, sx, sy, sWidth, sHeight, 0, 0, hiddenCanvas.width, hiddenCanvas.height);
            ctx.restore(); // Restore the context after mirroring transform

            // Get the image data as a PNG data URL
            const imageDataUrl = hiddenCanvas.toDataURL('image/png');

            let targetInput, targetPreview, targetText, targetRemoveBtn;

            if (currentPalmTarget === 'left') {
                targetInput = leftPalmInput;
                targetPreview = leftPalmPreview;
                targetText = leftPalmText;
                targetRemoveBtn = leftPalmRemoveBtn;
            } else if (currentPalmTarget === 'right') {
                targetInput = rightPalmInput;
                targetPreview = rightPalmPreview;
                targetText = rightPalmText;
                targetRemoveBtn = rightPalmRemoveBtn;
            }

            if (targetInput && targetPreview && targetText && targetRemoveBtn) {
                targetPreview.src = imageDataUrl;
                targetPreview.style.display = 'block';
                targetText.style.display = 'none';
                targetInput.value = imageDataUrl;
                targetRemoveBtn.classList.remove('hidden'); // Show remove button
            }

            updateMessageBox('Image captured successfully!', 'success');
            closeCameraModal(); // Close the modal after capture
        }

        /**
         * Removes a captured image from the display and clears the hidden input.
         * @param {string} palm - 'left' or 'right' to indicate which palm image to remove.
         */
        function removeImage(palm) {
            let targetInput, targetPreview, targetText, targetRemoveBtn;

            if (palm === 'left') {
                targetInput = leftPalmInput;
                targetPreview = leftPalmPreview;
                targetText = leftPalmText;
                targetRemoveBtn = leftPalmRemoveBtn;
            } else if (palm === 'right') {
                targetInput = rightPalmInput;
                targetPreview = rightPalmPreview;
                targetText = rightPalmText;
                targetRemoveBtn = rightPalmRemoveBtn;
            }

            if (targetInput && targetPreview && targetText && targetRemoveBtn) {
                targetInput.value = ''; // Clear the hidden input value
                targetPreview.src = ''; // Clear the image source
                targetPreview.style.display = 'none'; // Hide the image
                targetText.style.display = 'flex'; // Show the text again (flex for centering)
                targetRemoveBtn.classList.add('hidden'); // Hide the remove button
                updateMessageBox(`${palm === 'left' ? 'Left' : 'Right'} palm image removed.`, 'info');
            }
        }

        // --- Modal Control Functions ---

        /**
         * Opens the camera modal and initializes the camera.
         * @param {string} palm - 'left' or 'right' to indicate which palm is being captured.
         */
        async function openCameraModal(palm) {
            currentPalmTarget = palm;
            modalTitle.textContent = `Capture ${palm === 'left' ? 'Left' : 'Right'} Palm Photo`;
            cameraModal.classList.add('show');
            await initCamera(); // Initialize camera when modal opens
        }

        /**
         * Closes the camera modal and stops the camera.
         */
        function closeCameraModal() {
            cameraModal.classList.remove('show');
            stopCamera(); // Stop camera when modal closes
            currentPalmTarget = null; // Clear target
            updateMessageBox('', 'info'); // Clear message box
        }

        // --- Event Listeners ---

        // Listen for clicks on the capture trigger buttons
        captureTriggerButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                const palm = event.target.dataset.palm;
                openCameraModal(palm);
            });
        });

        // Listen for clicks on the remove image buttons
        removeImageButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                const palm = event.target.dataset.palm;
                removeImage(palm);
            });
        });

        closeModalBtn.addEventListener('click', closeCameraModal);

        zoomInBtn.addEventListener('click', () => {
            if (zoomCapabilities) {
                let newZoom = currentZoom + (zoomCapabilities.step || (zoomCapabilities.max - zoomCapabilities.min) / 10);
                applyZoom(newZoom);
            }
        });

        zoomOutBtn.addEventListener('click', () => {
            if (zoomCapabilities) {
                let newZoom = currentZoom - (zoomCapabilities.step || (zoomCapabilities.max - zoomCapabilities.min) / 10);
                applyZoom(newZoom);
            }
        });

        zoomSlider.addEventListener('input', (event) => {
            if (zoomCapabilities) {
                const newZoom = parseFloat(event.target.value);
                applyZoom(newZoom);
            }
        });

        captureBtn.addEventListener('click', captureImage);

        // --- Initial Load ---
        window.onload = async () => {
            await loadHandposeModel(); // Load the ML model once when the page loads
            // Camera will be initialized when the modal is opened
        };

        // Cleanup: Stop camera stream if the page is closed (as a fallback, modal close handles it too)
        window.addEventListener('beforeunload', () => {
            stopCamera();
        });
    </script>
</body>
</html>
